////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//	
// Description:
//
// Modification History:
// 2014/10/26 Created by Chen Ding
////////////////////////////////////////////////////////////////////////////
#include "GenericObjs/RandomData/RunTorturer.h"

#include "alarm_c/alarm.h"
#include "Alarm/Alarm.h"
#include "API/AosApi.h"
#include "Jimo/Ptrs.h"
#include "Rundata/Rundata.h"
#include "SEInterfaces/ExprObj.h"
#include "SEUtil/ParmNames.h"
#include "Util/OmnNew.h"
#include "XmlUtil/XmlTag.h"
#include "JQLParser/JQLParser.h"
#include "DataRecord/RecordParmList.h"

static OmnMutex sgLock;
static int sgInited = false;
static ma<OmnString, OmnString> sgTorturerNames;
static ma<OmnString, OmnString> sgTorturerConfig;

static void sgInit()
{
	sgTorturerNames["xml_torturer"] = "xml_doc_test.exe";
	sgTorturerConfig["xml_torturer"] = "config_xml_doc_tester.txt";
}


extern "C"
{

AosJimoPtr AosCreateJimoFunc_AosMethodRunTorturer_1(const AosRundataPtr &rdata, const int version)
{
	try
	{
		OmnScreen << "To create Jimo: " << endl;
		AosJimoPtr jimo = OmnNew AosMethodRunTorturer(version);
		aos_assert_r(jimo, 0);
		return jimo;
	}

	catch (...)
	{
		AosSetErrorU(rdata, "Failed creating jimo") << enderr;
		return 0;
	}

	OmnShouldNeverComeHere;
	return 0;
}
}


AosMethodRunTorturer::AosMethodRunTorturer(const int version)
:
AosGenericMethod(version)
{
	if (!sgInited)
	{
		sgLock.lock();
		if (!sgInited)
		{
			sgInit();
		}
		sgLock.unlock();
	}
}


AosMethodRunTorturer::~AosMethodRunTorturer()
{
}


bool
AosMethodRunTorturer::config(
		const AosRundataPtr &rdata,
		const AosXmlTagPtr &worker_doc,
		const AosXmlTagPtr &jimo_doc)
{
	return true;
}


AosJimoPtr 
AosMethodRunTorturer::cloneJimo() const
{
	return OmnNew AosMethodRunTorturer(*this);
}


bool 
AosMethodRunTorturer::proc(
		AosRundata *rdata,
		const OmnString &torturer_name, 
		const vector<AosGV> &parms)
{
	// This function runs a torturer. 
	// 	run "torturer" "xml_torturer"
	// 	(
	// 		'testers':'tester:weight,tester:weight...',
	// 		'tries':'10000',
	// 		'time':'ddd',
	// 	);

	select <field_list> 

	vector<AosExprObjPtr> fields = getParm("fields");
	AosExprObjPtr fields = getParm("fields");
	if (!fields->isArray())
	{
		OmnAlarm << "xxx";
	}

	// Check whether there is AOSPARM_DATAGEN_JIMO. If yes, we will
	// use that jimo to generate data.
	AosDataRecordObjPtr record = AosCreateDataRecord(rdata, parms);

	OmnString type = 
	// There is no jimo name. Data will be generated by the system 
	// defined data generators. 
	OmnString testers = record->getFieldValue(rdata, AOSPARM_TESTERS);
	vector<OmnString> tester_names;
	vector<int> tester_weights;
	if (testers == "")
	{
		// It is to test all.
	}
	else
	{
		// 'testers' should be in the form:
		vector<OmnString> pairs;
		AosSplitStr(testers, ",", pairs, eMaxTesters);
		for (u32 i=0; i<pairs.size(); i++)
		{
			vector<OmnString> entry;
			AosSplitStr(pairs[i], ":", entry, 2);
			tester_names.push_back(entry[0]);
			tester_weight(atoi(entry[1]));
		}
	}

	itr_t itr = sgTorturerNames.find(torturer_name);
	AosXmlTagPtr config = sgTorturerConfig.find(...);
	if (itr == sgTorturerNames.end())
	{
		AosLogError(rdata, true, AosErrmsgId::eTorturerNotFound) 
			<< AosFieldEnumName::eTorturerName << torturer_name << enderr;
		return false;
	}

	// Run the torturer:
	// 	torturer -config config
	OmnString command = itr->second;
	command << " -config " << config_name;
	OmnScreen << "Command: " << command << endl;
	system(command);
	return true;
}


