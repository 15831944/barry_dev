////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//	
// Description:
//
// Modification History:
// 2014/10/26 Created by Chen Ding
////////////////////////////////////////////////////////////////////////////
#include "GenericObjs/RandDataGen/CreateRandomData.h"
#include "alarm_c/alarm.h"
#include "Alarm/Alarm.h"
#include "API/AosApi.h"
#include "Jimo/Ptrs.h"
#include "Rundata/Rundata.h"
#include "SEInterfaces/ExprObj.h"
#include "SEUtil/ParmNames.h"
#include "Util/OmnNew.h"
#include "XmlUtil/XmlTag.h"
#include "JQLParser/JQLParser.h"

static OmnString sgChinaCellPrefixes = "130,131,132";

extern "C"
{
AosJimoPtr AosCreateJimoFunc_AosMethodCreateRandomData_1(const AosRundataPtr &rdata, const int version)
{
	try
	{
		OmnScreen << "To create Jimo: " << endl;
		AosJimoPtr jimo = OmnNew AosMethodCreateRandomData(version);
		aos_assert_r(jimo, 0);
		return jimo;
	}

	catch (...)
	{
		AosSetErrorU(rdata, "Failed creating jimo") << enderr;
		return 0;
	}

	OmnShouldNeverComeHere;
	return 0;
}
}


AosMethodCreateRandomData::AosMethodCreateRandomData(const int version)
:
AosGenericMethod(version)
{
}


AosMethodCreateRandomData::~AosMethodCreateRandomData()
{
}


bool
AosMethodCreateRandomData::config(
		const AosRundataPtr &rdata,
		const AosXmlTagPtr &worker_doc,
		const AosXmlTagPtr &jimo_doc)
{
	return true;
}


AosJimoPtr 
AosMethodCreateRandomData::cloneJimo() const
{
	return OmnNew AosMethodCreateRandomData(*this);
}


bool 
AosMethodCreateRandomData::proc(
		AosRundata *rdata,
		const OmnString &data_name, 
		const vector<AosGenericValueObjPtr> &parms)
{
	// This function creates random data. Data can be generated in one of
	// two ways: (1) Using a jimo, (2) Through system defined. 
	// The JQL format:
	// 	create "random_data" "name"
	// 	(
	// 		entries: 200000,
	// 		format: 'csv',
	// 		field: "filedname:username, data_type:string, random:digitstr, minlen:5, maxlen:20",
	// 		field: "filedname:sales,    data_type:u64,    random:digitstr, minlen1000, maxlen:100000"
	// 	);
	// 'name' can be empty. 

	// Check whether there is AOSPARM_DATAGEN_JIMO. If yes, we will
	// use that jimo to generate data.
	AosDataRecordObjPtr record = AosCreateDataRecord(rdata, parms);
	OmnString jimo_name=record->getFieldValue(rdata,AOSPARM_DATAGEN_JIMO);
	if (jimo_name == "")
	{
		/*
		int version=atoi(m_MapPhone[AOSPARM_VERSION].data());
		AosJimoPtr jimo = AosCreateJimo(rdata, "", version);//2
		if (!jimo)
		{
			// AosSetErrorUser(rdata, "jimo_not_found")
			// 	<< ErrorPair("Jimo Name") << jimo_name << enderr;
			return false;
		}

		AosMethodCreateRandomData *data_gen = dynamic_cast<AosMethodCreateRandomData*>(jimo.getPtr());
		if (!data_gen)
		{
			AosSetErrorUser(rdata, "internal_error") << enderr;
			return false;
		}

		return data_gen->generateData(rdata, data_name, parms);
		*/
		OmnNotImplementedYet;
		return false;
	}

	// Retrieve 'entries'
	AosValueRslt vv;
	record->getFieldValue(AOSTAG_ENTRIES, vv, false, rr);
	int entries = vv.getValueInt();

	// Retrieve 'field'
	vector<AosGenericValueObjPtr> field_defs;
	record->getFieldValue("field", field_defs, rdata);

	for (u32 i=0; i<field_defs.size(); i++)
	{
		AosGenericValueObjPtr field_def = field_defs[i];
		AosExprObjPtr expr = field_def->getValue();
		OmnString str = expr->getValue(...);
	}

	// There is no jimo name. Data will be generated by the system 
	// defined data generators. 
	OmnString type = record->getFieldValue(rdata,AOSPARM_TYPE);
	if (type == AOSPARMVALUE_MAP_TORTURER)
	{
		return generateMapTorturer(rdata, data_name, parms);
	}
	if (type == AOSPARMVALUE_PHONE_NUMBER)
	{
		return generatePhoneNums(rdata, data_name, parms);
	}
	/*AosSetErrorUser(rdata, "unrecognized_type") 
		<< ErrorPair("Type") << enderr;*/
	return false;
}


bool
AosMethodCreateRandomData::generateMapTorturer(
		AosRundata *rdata,
		const OmnString &data_name, 
		const AosDataRecordObjPtr &parms)
{
	OmnNotImplementedYet;
	return false;
}


bool
AosMethodCreateRandomData::generatePhoneNums(
		AosRundata *rdata,
		const OmnString &data_name, 
		const vector<AosExprObjPtr> &parms)
{
	// This function generates random phone numbers. 
	
	// 1. Check whether to generate cell phone numbers.
	//AosRecordParmListPtr record = OmnNew AosRecordParmList(parms,false);
	AosDataRecordObjPtr record = AosCreateDataRecord(rdata, parms);
	OmnString phone_num_type=record->getFieldValue(rdata,AOSPARM_PHONE_NUM_TYPE);
	if (phone_num_type == AOSPARMVALUE_CELL)
	{
		return generateCellNums(rdata, data_name, parms);
	}
	return generateNormPhoneNums(rdata, data_name, parms);
}


bool
AosMethodCreateRandomData::generateCellNums(
		AosRundata *rdata,
		const OmnString &data_name, 
		const vector<AosExprObjPtr> &parms)
{
	// It assumes the following parms:
	// 		min_num:"ddd",
	// 		max_num:"ddd",
	// 		separator:",",
	// 		prefix="130,139,150,180,186"
	//AosRecordParmListPtr record = OmnNew AosRecordParmList(parms,false);
	AosDataRecordObjPtr record =AosCreateDataRecord(rdata, parms);
	OmnString file_name =record->getFieldValue(rdata,AOSPARM_FILE_NAME);
	if(file_name  == "")
		return false;
	OmnString separator =record->getFieldValue(rdata,AOSPARM_PHONE_SEPARATOR);
	if(separator  == "")
		return false;
	OmnString str_min =record->getFieldValue(rdata,AOSPARM_PHONE_MIN_NUM);
	if(str_min    == "")
		return false;
	OmnString str_max =record->getFieldValue(rdata,AOSPARM_PHONE_MAX_NUM);
	if(str_max    == "")
		return false;
	int min = atoi(str_min.data());
	int max = atoi(str_max.data());
	if (min < 1) min = eDefaultMin;
	if (max < min) max = min;
	
	OmnString prefix=record->getFieldValue(rdata,AOSPARM_PHONE_PREFIX);
	if(prefix == "")
		return false;
    
	int num=(rand() % (max- min+ 1))+ min;
	vector<OmnString> prefix_list;
	if (prefix != "")
	{
		prefix_list = split(prefix, ',');
		bool rslt = createCellNumbers(num, separator, prefix_list,file_name);
		if(rslt) OmnScreen<<"create success"<<endl;
		return rslt;
	}
	else
	{
		prefix = sgChinaCellPrefixes;
		prefix_list = split(prefix, ',');
		bool rslt = createCellNumbers(num, separator, prefix_list,file_name);
		if(rslt) OmnScreen<<"create success"<<endl;
		return rslt;
		//OmnNotImplementedYet;
		return false;
	}
}


bool 
AosMethodCreateRandomData::createCellNumbers(
		const int num, 
		const OmnString &separator,
		const vector<OmnString> &prefix_list,
		const OmnString &file_name)
{
	int mMaxSize = 1024;
	int size = prefix_list.size();
	OmnString results;
	int phone_num_len = 8;
	FILE *p = fopen(file_name.data(), "w");
	if(p==NULL)
	{
		return false;
	}
	fclose(p);
	for(int i=0; i<num; i++)
	{
		if (i != 0) results << separator;
		int list_idx=rand()%size;
		results << prefix_list[list_idx] << OmnRandom::digitStr(phone_num_len, phone_num_len);
		if (results.length() > mMaxSize)
		{
			writeToFile(results, file_name);
			results = "";
		}
	}

	if (results != "")
	{
		writeToFile(results, file_name);
	}

	return true;
}


bool AosMethodCreateRandomData::writeToFile(const OmnString &phonenumber_list,const OmnString &filename)
{
	FILE *p=fopen(filename.data(),"ab+");
	if(p==NULL)
		return false;
	else
	{
		fwrite(phonenumber_list.data(), phonenumber_list.length()*sizeof(char), 1, p);
		fclose(p);
		return true;
	}
}


vector<OmnString> AosMethodCreateRandomData::split(OmnString &str,const char c)
{
	vector<OmnString> p;
	OmnString new_str;
	int i=0;
	int len=str.length();
	char s[4];
	int j=0;
	for(i=0;i<len;i++)
	{
		if(str[i]==c)
		{
			s[3]='\0';
			new_str<<s;
			j=0;
			p.push_back(new_str);
			new_str="";
			continue;
		}
		s[j]=str[i];
		j++;
	}
	s[3]='\0';
	p.push_back(s);
	return p;
}


bool
AosMethodCreateRandomData::generateNormPhoneNums(
		AosRundata *rdata,
		const OmnString &data_name, 
		const vector<AosExprObjPtr> &parms)
{
	OmnNotImplementedYet;
	return false;
}


bool
AosMethodCreateRandomData::generateIntegers(
		AosRundata *rdata,
		const OmnString &data_name, 
		const vector<AosExprObjPtr> &parms)
{
	// This function generates a random integer:
	// 	min: <ddd>,
	//	max: <ddd>
	OmnNotImplementedYet;
	return false;
}

