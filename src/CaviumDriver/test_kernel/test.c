////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// File Name: test.h
// Description:
//   
//
// Modification History:
// 
////////////////////////////////////////////////////////////////////////////
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/version.h>
#include <linux/param.h>
#include <linux/sched.h>
#include <linux/types.h>
#include <linux/unistd.h>
#include <linux/slab.h>
#include <linux/syscalls.h>
#include <linux/init.h>
#include <linux/random.h>
#include <linux/time.h>
#include <asm/uaccess.h>

#include "test.h"

Uint8 aosCert[]={
	0x30, // the start of the first cert
	0x82, 0x02, 0x89, 0x30, 0x82, 0x01, 0xf2, 0x02, 0x01, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
	0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x30, 0x81, 0x88, 0x31, 0x0b, 0x30, 0x09,
	0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55,
	0x04, 0x08, 0x13, 0x07, 0x62, 0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31, 0x10, 0x30, 0x0e, 0x06,
	0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x62, 0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31, 0x0f, 0x30,
	0x0d, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x06, 0x41, 0x4f, 0x53, 0x4c, 0x54, 0x44, 0x31, 0x0c,
	0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x03, 0x41, 0x4f, 0x53, 0x31, 0x0e, 0x30, 0x0c,
	0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x05, 0x41, 0x4f, 0x53, 0x43, 0x41, 0x31, 0x26, 0x30, 0x24,
	0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x17, 0x61, 0x6f, 0x73,
	0x63, 0x61, 0x40, 0x69, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65,
	0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x35, 0x30, 0x39, 0x31, 0x35, 0x30, 0x39,
	0x30, 0x31, 0x31, 0x31, 0x5a, 0x17, 0x0d, 0x30, 0x36, 0x30, 0x39, 0x31, 0x35, 0x30, 0x39, 0x30,
	0x31, 0x31, 0x31, 0x5a, 0x30, 0x81, 0x90, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
	0x13, 0x02, 0x43, 0x4e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x07, 0x62,
	0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13,
	0x07, 0x62, 0x65, 0x69, 0x6a, 0x69, 0x6e, 0x67, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04,
	0x0a, 0x13, 0x06, 0x41, 0x4f, 0x53, 0x4c, 0x54, 0x44, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55,
	0x04, 0x0b, 0x13, 0x03, 0x41, 0x4f, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x03,
	0x13, 0x09, 0x41, 0x6f, 0x73, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x31, 0x2a, 0x30, 0x28, 0x06,
	0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x1b, 0x61, 0x6f, 0x73, 0x73,
	0x65, 0x72, 0x76, 0x65, 0x72, 0x40, 0x69, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x65, 0x6e, 0x67,
	0x69, 0x6e, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
	0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89,
	0x02, 0x81, 0x81, 0x00, 0xc7, 0xa7, 0x41, 0x27, 0x66, 0x58, 0x1d, 0xf1, 0xf0, 0x73, 0x80, 0xad,
	0xcd, 0x73, 0x86, 0xab, 0x2e, 0x9d, 0x21, 0x49, 0x0e, 0x12, 0x81, 0x46, 0x2d, 0x99, 0x76, 0x5d,
	0x7d, 0xdb, 0x5c, 0xc5, 0x71, 0xd6, 0x82, 0xb1, 0xac, 0x16, 0x66, 0xd2, 0x89, 0x06, 0x7a, 0x65,
	0xb2, 0x0a, 0x5f, 0x44, 0x53, 0x8c, 0x12, 0xad, 0x30, 0xa0, 0x53, 0xa8, 0x84, 0x5c, 0x68, 0xc0,
	0x7c, 0x29, 0xd1, 0x74, 0xa1, 0x42, 0x13, 0x26, 0xc0, 0xc4, 0x5d, 0xfc, 0x0e, 0x1c, 0x83, 0x08,
	0xa5, 0x8d, 0x12, 0x03, 0x00, 0x9a, 0x40, 0x6e, 0x64, 0x23, 0xe6, 0xa6, 0x0a, 0xa0, 0xa8, 0xf7,
	0xd2, 0xa9, 0xb1, 0xd6, 0x47, 0x19, 0x08, 0xa0, 0xef, 0x9b, 0x9c, 0x3a, 0xac, 0x4f, 0xfc, 0x30,
	0x51, 0x16, 0xbb, 0x25, 0x8a, 0xb7, 0x1e, 0x5b, 0x0d, 0xdf, 0x5e, 0xa2, 0xd5, 0xb1, 0x44, 0x12,
	0x06, 0x03, 0xda, 0xbd, 0x02, 0x03, 0x01, 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
	0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x52, 0x11, 0xfe, 0x5e,
	0x0c, 0xc9, 0x81, 0x34, 0x8f, 0x36, 0x6a, 0xcf, 0x8d, 0x6b, 0xd8, 0x8a, 0x80, 0xf8, 0x75, 0x10,
	0x3d, 0x27, 0x56, 0x3e, 0x90, 0xec, 0x48, 0xda, 0x80, 0xf1, 0x2d, 0x97, 0x41, 0x6f, 0xbe, 0x33,
	0x81, 0x46, 0x4a, 0xf8, 0x1c, 0xbc, 0x58, 0x09, 0x1e, 0x95, 0x09, 0x39, 0x49, 0x4f, 0x69, 0xf7,
	0x3b, 0x1c, 0x6d, 0xd7, 0xb8, 0x49, 0x0b, 0x86, 0xc9, 0xbd, 0x1b, 0x7a, 0x4e, 0x7b, 0xd3, 0x02,
	0x2c, 0xfe, 0xf6, 0x8e, 0xf2, 0x84, 0x64, 0xf3, 0x78, 0xd6, 0xad, 0xe7, 0xdc, 0x0e, 0x91, 0x3b,
	0x57, 0x98, 0x36, 0xe0, 0x07, 0xdc, 0x4d, 0x6d, 0x3b, 0xcb, 0xde, 0x90, 0xeb, 0x79, 0xd3, 0xec,
	0xc6, 0xf6, 0x9e, 0x35, 0xb9, 0x91, 0xfe, 0x11, 0x33, 0x7e, 0xec, 0xc2, 0x4a, 0xa4, 0xbb, 0xc5,
	0x85, 0xb5, 0x5f, 0x29, 0x2a, 0xde, 0xd5, 0xf9, 0x22, 0xe2, 0x65, 0x20}; 

Uint8 modulus[MAX_RSA_MODULUS_LEN]={
	0xc7, 0xa7, 0x41, 0x27, 0x66, 0x58, 0x1d, 0xf1, 0xf0, 0x73, 0x80, 0xad, 0xcd, 0x73, 0x86, 0xab, 
    0x2e, 0x9d, 0x21, 0x49, 0x0e, 0x12, 0x81, 0x46, 0x2d, 0x99, 0x76, 0x5d, 0x7d, 0xdb, 0x5c, 0xc5, 
    0x71, 0xd6, 0x82, 0xb1, 0xac, 0x16, 0x66, 0xd2, 0x89, 0x06, 0x7a, 0x65, 0xb2, 0x0a, 0x5f, 0x44, 
    0x53, 0x8c, 0x12, 0xad, 0x30, 0xa0, 0x53, 0xa8, 0x84, 0x5c, 0x68, 0xc0, 0x7c, 0x29, 0xd1, 0x74, 
    0xa1, 0x42, 0x13, 0x26, 0xc0, 0xc4, 0x5d, 0xfc, 0x0e, 0x1c, 0x83, 0x08, 0xa5, 0x8d, 0x12, 0x03, 
    0x00, 0x9a, 0x40, 0x6e, 0x64, 0x23, 0xe6, 0xa6, 0x0a, 0xa0, 0xa8, 0xf7, 0xd2, 0xa9, 0xb1, 0xd6, 
    0x47, 0x19, 0x08, 0xa0, 0xef, 0x9b, 0x9c, 0x3a, 0xac, 0x4f, 0xfc, 0x30, 0x51, 0x16, 0xbb, 0x25, 
    0x8a, 0xb7, 0x1e, 0x5b, 0x0d, 0xdf, 0x5e, 0xa2, 0xd5, 0xb1, 0x44, 0x12, 0x06, 0x03, 0xda, 0xbd
};

Uint8 privateExponent[MAX_RSA_MODULUS_LEN]={
	0x6b, 0xef, 0x49, 0xd3, 0xe9, 0x0a, 0x5e, 0x35, 0xfb, 0xce, 0x15, 0x94, 0xe0, 0x6b, 0x42, 0x34, 
    0xad, 0x20, 0x99, 0x6c, 0x0b, 0x45, 0x89, 0xc9, 0xcc, 0xc1, 0x18, 0x32, 0x76, 0xe5, 0xee, 0x83,
    0x77, 0x85, 0x86, 0x66, 0x53, 0x28, 0x51, 0x32, 0x24, 0x8d, 0xf2, 0x01, 0xa4, 0x7c, 0xe2, 0xff,
    0xe7, 0x42, 0xe4, 0x9d, 0xe8, 0x99, 0xe4, 0x60, 0x48, 0x1e, 0x45, 0x2b, 0x3a, 0x74, 0xc9, 0x1c,
    0x94, 0x71, 0xcd, 0x73, 0x27, 0x87, 0xaa, 0xb8, 0x64, 0x37, 0x9f, 0x67, 0x89, 0x7f, 0x70, 0x6f,
    0xeb, 0xe3, 0x06, 0xb4, 0x2f, 0xcd, 0x77, 0xaa, 0x6b, 0x3a, 0x8d, 0x01, 0x44, 0xe8, 0x85, 0x2f,
    0x87, 0x80, 0x43, 0xb7, 0x73, 0xaf, 0xc4, 0xf1, 0xa9, 0x93, 0x65, 0x7d, 0xf8, 0x74, 0xe0, 0x48,
    0x5a, 0xba, 0xc6, 0x9f, 0xeb, 0x24, 0x45, 0x44, 0xad, 0xb5, 0x1c, 0x3a, 0xaa, 0x4b, 0x89, 0xa9
};

Uint8 prime[2][MAX_RSA_PRIME_LEN]={
   {
		0xfb, 0x94, 0xd8, 0x1a, 0x74, 0xd9, 0x0b, 0x70, 0x4f, 0x05, 0x83, 0x1c, 0xa5, 0x6b, 0x09, 0x8a,
    	0x13, 0xac, 0x55, 0x21, 0x79, 0x10, 0xa3, 0x18, 0xc8, 0x05, 0xa6, 0xbe, 0xa9, 0xca, 0x26, 0xed,
    	0x05, 0x07, 0x5d, 0xea, 0x02, 0x2f, 0x7d, 0xd2, 0x9b, 0x2f, 0x7a, 0x1d, 0x3a, 0x60, 0xa8, 0x6c,
    	0x4f, 0xbd, 0x18, 0xa5, 0xdf, 0x19, 0xb4, 0x8c, 0x7e, 0x38, 0x4d, 0xd8, 0x21, 0xf8, 0x82, 0xab
   },
   {
		0xcb, 0x28, 0xee, 0xa7, 0x29, 0x42, 0x7d, 0x3f, 0x8d, 0xc8, 0x67, 0x3d, 0x05, 0x5b, 0x6e, 0xdc,
    	0xcf, 0x05, 0xf9, 0xd0, 0xa2, 0xc0, 0x16, 0x6c, 0x0b, 0x95, 0x5b, 0x4c, 0xfc, 0xb2, 0xab, 0xe7,
    	0x0a, 0xc7, 0xe6, 0x66, 0x3c, 0xb8, 0x84, 0x4e, 0x09, 0x6e, 0x6f, 0x4e, 0xa7, 0xfe, 0xea, 0x5a,
    	0x5a, 0x1f, 0xf9, 0xb1, 0xa4, 0xd5, 0xee, 0xec, 0xd4, 0xce, 0xcd, 0x28, 0x6e, 0x1f, 0x58, 0x37
   }
};

Uint8 primeExponent[2][MAX_RSA_PRIME_LEN]={
   { 
		0x87, 0xaa, 0x7b, 0x62, 0xc0, 0xf2, 0x2e, 0x3d, 0xf1, 0x0f, 0x0a, 0xe6, 0x0e, 0xba, 0x0a, 0xd9,
    	0xdf, 0xc4, 0x05, 0xe0, 0x58, 0x15, 0xc5, 0xad, 0xde, 0x67, 0x55, 0xc4, 0xe9, 0x70, 0xae, 0xcf,
    	0x0f, 0xf0, 0x2a, 0x0f, 0xbf, 0xff, 0xf6, 0x3c, 0xf5, 0x1c, 0x84, 0x20, 0x70, 0xd3, 0xa0, 0xdf,
    	0x4f, 0x9c, 0xac, 0x46, 0xfe, 0x69, 0x31, 0x38, 0xb5, 0xf4, 0x0c, 0xde, 0x69, 0x6b, 0x46, 0xa3  
   },
   {
		0x96, 0x66, 0xf9, 0x37, 0x5b, 0xbe, 0x53, 0x87, 0x27, 0x6a, 0x03, 0xb4, 0x13, 0x31, 0x3b, 0x83,
    	0xd0, 0xe7, 0xf5, 0xa7, 0xd5, 0xb5, 0x2b, 0x64, 0x55, 0xb6, 0xfe, 0xde, 0xa1, 0xfd, 0x8c, 0x72,
    	0x01, 0x73, 0x38, 0x48, 0xdc, 0x0f, 0x26, 0x33, 0xb7, 0x9b, 0xc0, 0x5f, 0x94, 0xd3, 0x8d, 0x9f,
    	0xd2, 0x34, 0xf5, 0xdf, 0xe3, 0xce, 0x55, 0x91, 0x93, 0x82, 0x7e, 0x33, 0xbe, 0x43, 0x0a, 0x45
   }
};

Uint8 coefficient[MAX_RSA_PRIME_LEN]={
	0x18, 0xd6, 0x24, 0xa3, 0x97, 0x8e, 0xdf, 0xff, 0x88, 0x58, 0x40, 0xf6, 0x47, 0x97, 0x4d, 0xaa,
    0xbb, 0xcd, 0xd1, 0x23, 0x03, 0xbe, 0xb2, 0x60, 0xd1, 0x3e, 0x17, 0x8d, 0xc2, 0x3e, 0x3e, 0x51,
    0x8a, 0x1d, 0xe3, 0x83, 0x7d, 0x55, 0x31, 0x9d, 0xe5, 0x34, 0xa4, 0x39, 0xf6, 0x54, 0xc1, 0xa5,
    0x40, 0xf2, 0xe8, 0x2e, 0xbd, 0xe4, 0xed, 0xda, 0xf0, 0x44, 0x8a, 0xa4, 0xb3, 0x9e, 0x4b, 0xf3
};

Uint8 ca_dn[]={
	0x00, 0x8b, // ca dn length
	0x30, 0x81, 0x88, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e,
	0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x07, 0x62, 0x65, 0x69, 0x6a, 0x69,
	0x6e, 0x67, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x62, 0x65, 0x69,
	0x6a, 0x69, 0x6e, 0x67, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x06, 0x41,
	0x4f, 0x53, 0x4c, 0x54, 0x44, 0x31, 0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x03,
	0x41, 0x4f, 0x53, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x05, 0x41, 0x4f,
	0x53, 0x43, 0x41, 0x31, 0x26, 0x30, 0x24, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
	0x09, 0x01, 0x16, 0x17, 0x61, 0x6f, 0x73, 0x63, 0x61, 0x40, 0x69, 0x70, 0x61, 0x63, 0x6b, 0x65,
	0x74, 0x65, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x2e, 0x63, 0x6f, 0x6d
};


//extern void hello(void);
extern Uint32 Csp1Initialize(Csp1DmaMode dma_mode);
extern Uint32 Csp1AllocContext(ContextType cntx_type, Uint64 *context_handle);
extern Uint32 Csp1Shutdown (void);
extern Uint32 Kernel_Csp1InitializeRc4(n1_request_type request_type,
              Uint64 context_handle, 
              Uint16 key_length, 
              Uint8 *key,
              Uint32 *request_id,
              void (*call_back)(int, void*),
              void* connect);	
extern Uint32 
Kernel_Csp1EncryptRc4(n1_request_type request_type,
            Uint64 context_handle, 
            ContextUpdate context_update, 
            Uint16 length, 
            Uint8 *input, 
            Uint8* output,
            Uint32 *request_id,
              void (*call_back)(int, void*),
              void* connect);
extern Uint32 Kernel_Csp1DecryptAes(n1_request_type request_type,
            Uint64 context_handle, 
            ContextUpdate context_update, 
            AesType aes_type, 
            Uint16 length, 
            Uint8 *input, 
            Uint8* output,
            Uint8 *iv,
            Uint8 *key,
            Uint32 *request_id,
			void (*call_back)(int, void *),
			void *connect);
extern Uint32 Kernel_Csp1EncryptAes(n1_request_type request_type,
            Uint64 context_handle, 
            ContextUpdate context_update, 
            AesType aes_type, 
            Uint16 length, 
            Uint8 *input, 
            Uint8* output,
            Uint8 *iv,
            Uint8 *key,
            Uint32 *request_id,
			void (*call_back)(int, void *),
			void *connect);			
extern Uint32 
Kernel_Csp1Pkcs1v15CrtEnc(n1_request_type request_type,
               RsaBlockType block_type,
               Uint16 modlength, 
               Uint16 datalength, 
               Uint8 *Q, 
               Uint8 *Eq, 
               Uint8 *P, 
               Uint8 *Ep, 
               Uint8 *iqmp, 
               Uint8 *data,
               Uint8 *result,
               Uint32 *request_id,
               void (*call_back)(int, void*),
               void *connect);
extern Uint32 
Kernel_Csp1Pkcs1v15CrtDec(n1_request_type request_type,
               RsaBlockType block_type,
               Uint16 modlength, 
               Uint8 *Q, 
               Uint8 *Eq, 
               Uint8 *P, 
               Uint8 *Ep, 
               Uint8 *iqmp, 
               Uint8 *data,
               Uint16 *out_length,
               Uint8 *result,
               Uint32 *request_id,
			   void (*call_back)(int, void *),
			   void *connect);
extern Uint32 
Kernel_Csp1Pkcs1v15Enc(n1_request_type request_type,
            RsaBlockType block_type,
            Uint16 modlength, 
            Uint16 explength,
            Uint16 datalength, 
            Uint8 *modulus, 
            Uint8 *exponent, 
            Uint8 *data,
            Uint8 *result,
            Uint32 *request_id,
            void (*call_back)(int, void *),
            void* connect);
extern Uint32 
Kernel_Csp1Pkcs1v15Dec(n1_request_type request_type,
            RsaBlockType block_type,
            Uint16 modlength, 
            Uint16 explength,
            Uint8 *modulus, 
            Uint8 *exponent, 
            Uint8 *data,
            Uint16 *out_length,
            Uint8 *result,
            Uint32 *request_id,
            void (*call_back)(int, void*),
            void *connect);
	
	
			
Uint64 context_handle;
Uint32 request_id;


int initmodule(void);  
void cleanupmodule(void); 
//int test_callback(void);
Uint64 start_time, end_time;

  
module_init(initmodule);
module_exit(cleanupmodule);
MODULE_LICENSE("GPL");

//wait_queue_head_t wait;
//extern int test_callback_flag;




int initmodule(void)
{
//	int test_flag=test_rc4;
	int ret_val;
	
	//hello();
	set_current_state(TASK_INTERRUPTIBLE);
	
//	test_callback_flag=0;
	P("Init test module\n");
	//ret_val=Csp1Initialize(CAVIUM_DIRECT);
	//P("Csp1Initialize ret %d\n", ret_val);	

	//init_wait_queue_head(&wait);
	
	
	//test_block_main(test_flag);
	//test_no_block_main(test_flag);
	//none_blocking();
	//new_none_blocking();
	//test_aes();
	test_rsa();
	return 0;	
}

void test_initrc4_call_back(int flag, void* arg)
{
	struct rc4_struct *rc4;
	//struct rc4_struct *aaa=(struct rc4_struct*)arg;
	int i;

	free(arg);

	start_time=jiffies;
	for(i=0;i<TEST_COUNT;i++){
		rc4=(struct rc4_struct*)test_malloc(sizeof(struct rc4_struct));
		if(rc4==NULL){
			P("no memory\n");
			return ;
		}
		//if(i%100==0){
	//		P("input %d\n", i);
	//	}
		//P("address %x\n", (Uint8*)rc4);
		Kernel_Csp1EncryptRc4(CAVIUM_NON_BLOCKING,
				context_handle, 
				CAVIUM_NO_UPDATE, 
				DATA_LENGTH, 
				rc4->input, 
				rc4->output,
				&request_id,
				  test_encrypt_call_back,
				  rc4);
	}

	return;
}

void test_aes_decrypt_callback(int flag, void *arg)
{
	
	return ;
}

void test_encrypt_call_back(int flag, void* arg)
{
	struct rc4_struct* rc4=(struct rc4_struct*)arg;
	static long count=0;

	//Kernel_Csp1EncryptRc4(CAVIUM_NON_BLOCKING, context_handle, CAVIUM_NON_BLOCKING, DATA_LENGTH, rc4->output, rc4->outout, &request_id, test_decrypt_call_back, rc4);
	count++;
	//if(count%100==0){
	//	P("count %ld\n", count);
	//}
	if(count>=TEST_COUNT){
		end_time=jiffies;
		P("data length %ld, count=%ld\n", (long)((DATA_LENGTH*TEST_COUNT)>>20), count);
		P("time %ld\n", (long)(end_time-start_time));
		//free(rc4->input);
		//free(rc4->output);
		//free(rc4->outout);
		
	}

	free(rc4);
	return;


}

void test_decrypt_call_back(int flag, void* arg)
{
	struct rc4_struct *rc4=(struct rc4_struct*)arg;

	print_buf("input data", rc4->input, DATA_LENGTH);
	print_buf("output data", rc4->output, DATA_LENGTH);
	print_buf("outout data", rc4->outout, DATA_LENGTH);

	free(rc4->input);
	free(rc4->output);
	free(rc4->outout);
	free(rc4);

	
	return ;
}	
	
void test_aes_call_back(int flag, void *arg)
{

	
	return ;
}

int test_aes(void)
{
	Uint8* key;
	Uint8* in;
	Uint8* iv;
	Uint8* out;
	int i;
	
	key=test_malloc(32);
	iv=test_malloc(16);
	out=test_malloc(DATA_LENGTH);
	in=test_malloc(DATA_LENGTH);
	
	for(i=0;i<32;i++){
		key[i]=i&0xff;
	}
	for(i=0;i<16;i++){
		iv[i]=i&0xff;
	}
	for(i=0;i<DATA_LENGTH;i++){
		in[i]=i&0xff;
	}
	
	Kernel_Csp1EncryptAes(CAVIUM_NON_BLOCKING,
		            context_handle, 
		            CAVIUM_NO_UPDATE, 
		            AES_256, 
		            DATA_LENGTH, 
		            in, 
		            out,
		            iv,
		            key,
		            &request_id,
					test_aes_call_back,
					NULL);	
	
	
	return 0;
}



int new_none_blocking(void)
{

	int i;
	struct rc4_struct *rc4;

	Csp1AllocContext(CONTEXT_SSL, &context_handle);	

	rc4=(struct rc4_struct*)test_malloc(sizeof(struct rc4_struct));
/*	
	rc4->input=(Uint8*)test_malloc(DATA_LENGTH);
	rc4->output=(Uint8*)test_malloc(DATA_LENGTH);
	rc4->outout=(Uint8*)test_malloc(DATA_LENGTH);
*/	
		
	for(i=0;i<16;i++){
		rc4->key[i]=i&0xff;
	}

	for(i=0;i<DATA_LENGTH;i++){
		rc4->input[i]=i&0xff;
	}


	Kernel_Csp1InitializeRc4(CAVIUM_NON_BLOCKING,
	              context_handle, 
	              16, 
	              rc4->key,
	              &request_id,
	              test_initrc4_call_back,
	              rc4);
	
	return 0;
}

void test_rsa_call_back(int flag, void *arg)
{
	struct rsa_struct *rsa=(struct rsa_struct*)arg;
	Uint8 exp[128];


	memset(exp, 0, 128);
	exp[127]=1;
	exp[125]=1;

	print_buf("rsa input data", rsa->input, 124);
	print_buf("rsa out data", rsa->output, 128);

	Kernel_Csp1Pkcs1v15Dec(CAVIUM_NON_BLOCKING,
            BT1,
            128, 
            128,
            modulus, 
            exp, 
            rsa->output,
            (Uint16*)&rsa->outlength,
            rsa->out_out,
            &request_id,
            test_rsa_de_call_back,
            (void*)rsa);	
	P("rsa->out_length address is %x\n", (unsigned int)&rsa->outlength);

	return ;
}

void test_rsa_de_call_back(int flag, void *arg)
{
	struct rsa_struct *rsa=(struct rsa_struct*)arg;

	print_buf("rsa out_out data", rsa->out_out, 128);
	print_buf("rsa outlength data", &rsa->outlength, 4);
	P("rsa outlength address is %x\n", (unsigned int)&rsa->outlength);
	P("out_out length is %x\n", rsa->outlength);

	free(rsa);

	return ;
}





int test_rsa(void)
{
	Uint8 in[124];
	int i;
	struct rsa_struct *rsa;


	rsa=(struct rsa*)test_malloc(sizeof(struct rsa_struct));
	for(i=0;i<124;i++){
		rsa->input[i]=i&0xff;
	}	
	Kernel_Csp1Pkcs1v15CrtEnc(CAVIUM_NON_BLOCKING,
               BT1,
               128, 
               100, 
               prime[1], 
               primeExponent[1], 
               prime[0], 
               primeExponent[0], 
               coefficient, 
               rsa->input,
               rsa->output,
               &request_id,
               test_rsa_call_back,
               (void*)rsa);


	return 0;
}





















void cleanupmodule(void)
{
	//Csp1Shutdown();
	printk("cleanup module\n");
	return;
}


