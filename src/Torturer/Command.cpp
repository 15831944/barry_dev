////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This is the super class for all 'commands', which can be CLI commands,
// functions, system commands, etc., or anything that is atomically
// testable. 
//   
// mCorrectTable and mIncorrectTable
// The class maintains two database tables: mCorrectTable and 
// mIncorrectTable. If mCorrectTable is not null, it means that if
// we want to generate a correct command, the command must be
// chosen from the table. If it is null, a correct command should
// be generated by randomly generating values for its parameters.
// Similarly, when mIncorrectTable is not null, if we want to
// generate an incorrect command, it should be chosen from the
// table. 
//
// Modification History:
// 01/04/2008: Created by Allen Xu
//
////////////////////////////////////////////////////////////////////////////
#include "Torturer/Command.h"

#include "aos/aosReturnCode.h"
#include "alarm_c/alarm.h"
#include "Action/Action.h"
#include "Alarm/Alarm.h"
#include "Debug/Debug.h"
#include "RVG/Record.h"
#include "RVG/Parm.h"
#include "RVG/ConfigMgr.h"
#include "RVG/Table.h"
#include "Random/RandomUtil.h"
#include "SemanticRules/SemanticRule.h"
#include "Semantics/SemanticsReturnCodes.h"
#include "Semantics/SemanticsUtil.h"
#include "SemanticData/VarContainer.h"
#include "Tester/TestMgr.h"
#include "Thread/Mutex.h"
#include "Torturer/Torturer.h"
#include "Torturer/FuncCmd.h"
#include "Torturer/CliCmd.h"
#include "Conditions/Condition.h"
#include "Util/OmnNew.h"
#include "Util/File.h"
#include <math.h>

static OmnMutex sgLock;
static u32 sgCmdId = 0;
static std::string sgObjectTableName = "ObjectTable";

OmnFilePtr		AosCommand::mLogFile = NULL;

AosCommand::AosCommand(
		const std::string &cmdName, 
		const std::string &productName)
{
	mCmdName = cmdName;
	mProductName = productName;
	sgLock.lock();
	mId = sgCmdId++;
	sgLock.unlock();
	mLogType = AosTorturerLogType::eOnScreen;
}


AosCommand::AosCommand()
{
	sgLock.lock();
	mId = sgCmdId++;
	sgLock.unlock();
	mLogType = AosTorturerLogType::eOnScreen;
}


AosCommand::~AosCommand()
{
}




// 
// Description:
// If the correct percentage for a command is 'cmdCorrectPct'
// and that command has n number of arguments, each argument's
// correct percent will be 1 - root_n(cmdCorrectPct).
//
// Returns:
// [0, 100] if correct
// -1 if incorrect
int
AosCommand::calculateParmCrtPct(
						const int cmdCorrectPct, 
						const int numParms)
{
	aos_assert_r(cmdCorrectPct >= 0 && cmdCorrectPct <= 100, -1);
	aos_assert_r(numParms > 0 && numParms < eMaxArgs, -1);
	float fff = pow(cmdCorrectPct/100.0, 1.0/numParms);

	return (int) ((fff + 0.005)* 100);
}


bool
AosCommand::setParmCorrectPct()
{
	// 
	// Set the successful percentage
	//
	aos_assert_r(!mCorrectPctSet, false);
	u32 crtPct = calculateParmCrtPct(mCorrectPct, mArgs.size());
	AosParmPtrArray::iterator itr;
	for (itr = mArgs.begin(); itr != mArgs.end(); itr++)
	{
		(*itr)->setCorrectPct(crtPct);
	}

	mCorrectPctSet = true;
	return true;
}


bool
AosCommand::addArg(const AosParmPtr &arg)
{
	mArgs.push_back(arg);
	return true;
}


bool 
AosCommand::serialize(TiXmlNode& node)
{
	aos_not_implemented_yet;
	return true;
}


bool 
AosCommand::deserialize(TiXmlNode* node)
{
	// 
	// 	<Cmd>
	// 		<Name>
	// 		<ProductName>
	// 		<CorrectPct>
	// 		<Weight>
	// 		<Status>
	// 		<CorrectTable>
	// 		<IncorrectTable>
	// 		<CorrectConditions>
	// 		<IncorrectConditions>
	// 		<Parms>
	// 			<Parm>
	// 			</Parm>
	// 			...
	// 		</Parms>
	// 	</Cmd>
	//
	aos_assert_r(node, false);

	//
	// parse name, mandatory field
	//
	if (!node->getElementTextValue("Name", mCmdName))
	{
		OmnAlarm << "XML parse: Name must exist in Command" << enderr;
		return false;
	}

	//
	// parse ProductName, mandatory field
	//
	if (!node->getElementTextValue("ProductName", mProductName))
	{
		OmnAlarm << "XML parse: ProductName must exist in Command" << enderr;
		return false;
	}

	//
	// parse CorrectPct, mandatory field
	//
	if (!node->getElementTextValue("CorrectPct", mCorrectPct))
	{
		OmnAlarm << "XML parse: CorrectPct must exist in Command" << enderr;
		return false;
	}

	//
	// parse Weight, mandatory field
	//
	if (!node->getElementTextValue("Weight", mWeight))
	{
		OmnAlarm << "XML parse: CorrectPct must exist in Command" << enderr;
		return false;
	}

	//
	// parse Status, mandatory field
	//
	if (!node->getElementTextValue("Status", mStatus))
	{
		OmnAlarm << "XML parse: CorrectPct must exist in Command" << enderr;
		return false;
	}

	//
	// parse CorrectTable, optional field
	//
	TiXmlElement* element = node->FirstChildElement("CorrectTable");
	if (element)
	{
		mCorrectTable = OmnNew AosTable();
		mCorrectTable->deserialize(element);
	}

	//
	// parse IncorrectTable, optional field
	//
	element = node->FirstChildElement("IncorrectTable");
	if (element)
	{
		mIncorrectTable = OmnNew AosTable();
		mIncorrectTable->deserialize(element);
	}

	//
	// parse Parameter list
	//
	mArgs.clear();
	element = node->FirstChildElement("Parms");
	if (element)
	{
		AosParmPtr parm;
		TiXmlElement* child = element->FirstChildElement("Parm");	
		for (; child!=NULL; child=child->NextSiblingElement("Parm"))
		{
			parm = OmnNew AosParm();
			parm->deserialize(child);
			addArg(parm);
		}
	}

	return true;
}


// 
// Description:
// A Command contains zero or more arguments. Arguments
// are implemented as AosParms. Generating an instance of
// a command is to generate values for each of its
// arguments. This function retrieves the last generated value
// of the named argument, the value will be converted to string. 
//
bool
AosCommand::getCrtValue(const std::string &name, 
						std::string &value)
{
	AosParmPtr parm = getParm(name);
	if (!parm)
	{
		OmnAlarm << "RVG not found: " << name << enderr;
		return false;
	}

	AosValuePtr valuePtr;
	if (!parm->getCrtValue(valuePtr))
	{
		OmnAlarm << "Failed to retrieve parm value: " 
			<< name << enderr;
		return false;
	}
	if (valuePtr)
	{
		value = valuePtr->toString();
	}

	return true;
}


AosParmPtr 
AosCommand::getParm(const std::string &name)
{
	AosParmPtrArray::iterator itr;
	for (itr = mArgs.begin(); itr != mArgs.end(); itr++)
	{
		if ((*itr)->getName() == name)
		{
			return *itr;
		}
	}

	return 0;
}


bool
AosCommand::setCrtValue(const std::string &name, 
						   const std::string &value, 
						   std::string &errmsg)
{
	AosParmPtr parm = getParm(name);
	if (!parm)
	{
		errmsg += "To set Parameter value but not found: ";
		errmsg += name;
		errmsg += ":";
		errmsg += value;
	    errmsg += ". ";
		return false;
	}

	return parm->setCrtValue(value);
}


bool AosCommand::createCmdByParms(
		AosRecord &record, 
		const AosTablePtr &tableSelected,
		const AosCorCtrl::E expectedCorrectness, 
		bool &isGeneratedCmdCorrect,
		bool &cmdGeneratedFlag,
		std::string &cmdErrmsg,
		std::string &decl,
		std::string &deleteStmt, 
		std::string &cmd)
{
	AosValue arg;
	AosValuePtr ptr;
	bool isCorrect;
	std::string errmsg;

	isGeneratedCmdCorrect = true;

	// 
	// Generate the values for each RVG.
	// Note that not all RVGs need to generate values. An RVG 
	// needs to generate value only when it is of 'input' type. 
	//
	int argsNum = mArgs.size();
	int idx;
	for (idx=0; idx<argsNum; idx++)
	{
		// 
		// Check whether need to generate values for it.
		//
		if (mArgs[idx]->isInputType())
		{
			// 
			// Try to see whether we should select a value from
			// the record.
			//
			if (!record.isEmpty() && record.getValue(tableSelected, 
						mArgs[idx]->getName(), ptr))
			{
				// 
				// Got the value. 
				//
				arg = *ptr;
				mArgs[idx]->setCrtValue(ptr);
			}
			else
			{
				// 
				// Need to randomly generate the value
				//
				mArgs[idx]->setCorrectnessFlag(expectedCorrectness);
				aos_assert_rm(mArgs[idx]->nextValue(arg, 
						isGeneratedCmdCorrect, errmsg), false, 
						"Failed to create parm: %s. ErrMsg: %s", 
						mArgs[idx]->getName().data(), errmsg.data());

				// 
				// Did it generate the right one?
				//
				if (!isPossible(expectedCorrectness, isCorrect))
				{
					// 
					// Can't generate the right command for this call.
					//
					cmdGeneratedFlag = false;
					return true;
				}

				if (!isCorrect)
				{
					// 
					// Generated command is an incorrect one. Collect
					// the incorrect message. 
					//
					cmdErrmsg += errmsg;
					cmdErrmsg += ". ";
					isGeneratedCmdCorrect = false;
				}
			}
		}

		// 
		// Construct the command. This is command type dependent.
		//
		if (!constructCmd(idx, decl, deleteStmt, cmd))
		{
			OmnAlarm << "construct command error" << enderr;
			return false;
		}
	}

	return true;
}


// 
// Description:
// This function will generate a new command. A command
// is in the form of:
// 		<command_prefix> <arg1> <arg2> ... <argn>
// Generating a command is to generate a value for each of
// the arguments, randomly. The generated values for each 
// argument are stored in the arguments themselves. When 
// needed, call getCrtValue(...) to retrieve it.
//
// cmdCorrect(OUT): 	
// 		Indicate whether the command generated is 
//      correct or incorrect.
//
// correctFlag:
// 		Correct
// 		Incorrect
// 		Random: randomly determine whether correct/incorrect.
// 		This parm is used by the caller to control whether 
// 		to generate a correct, incorrect command, or the
// 		correctness of the generated command is randomly
// 		determined.
//
// tm:  Pointer to TestManager
//
// Return: 
//    true:   if a command was generated.
//    false:  if 'mCorrectCtrl' == 
//
bool
AosCommand::run(bool &isGeneratedCmdCorrect, 
				const AosCorCtrl::E expectedCorrectness,
				bool &cmdGeneratedFlag) 
{
	static u32 cmdId = 0;

	AosRecord record;
	bool cmdCorrect;
	bool possible;

	if (!mCorrectPctSet) setParmCorrectPct();

	// 
	// Determine whether need to use a record in the databasae table.
	//
	AosTablePtr	tableSelected;
	aos_assert_r(selectObject(expectedCorrectness, record, 
			tableSelected, cmdCorrect, possible), false); 
	if (record.isEmpty() && !possible)
	{
		// 
		// Cannot generate a command as expected.
		//
		cmdGeneratedFlag = false;
		return true;
	}

	// 
	// Generate the command now.
	//
	std::string decl;
	std::string deleteStmt;
	std::string cmdErrmsg;
	std::string cmd = getCmdPrefix();
	aos_assert_r(createCmdByParms(record, tableSelected, 
				expectedCorrectness, cmdCorrect,
				cmdGeneratedFlag, cmdErrmsg, decl, deleteStmt, 
				cmd), false);

	if (!cmdGeneratedFlag)
	{
		// 
		// Did not generate the command. 
		//
		return true;
	}

	// 
	// All parms have been instantiated. Continue constructing
	// the command. 
	//
	finishUpCmd(cmdId, decl, deleteStmt, cmd);

	if (!isPossible(expectedCorrectness, cmdCorrect))
	{
		cmdGeneratedFlag = false;
		return true;
	}

	// 
	// Perform PreSemantics checking
	//
	if (cmdCorrect)
	{
		aos_assert_r(doPreSemantics(cmdCorrect, cmdErrmsg), false);
	}

	if (!isPossible(expectedCorrectness, cmdCorrect)) 
	{
		cmdGeneratedFlag = false;
		return true;
	}

	if (cmdCorrect)
	{
		aos_assert_r(doCorrectPreActions(), false);
	}
	else
	{
		aos_assert_r(doIncorrectPreActions(), false);
	}

	OmnTrace << "To run command: " << getName() << endl;
	bool cmdExecuted = false;

	// 
	// Run the command. If errors were encountered, it will 
	// return false. Otherwise, it returns true. Execution should
	// always return true. Whether the command is actually 
	// executed is indicated by "cmdExecuted". Note that it is
	// possible that the command is not executed at all. 
	// Also note that whether
	// the command is correct or incorrect is still controlled
	// by 'cmdCorrect'. 
	//
	bool executionRslt = runCommand(expectedCorrectness, mTorturer, 
			mTestMgr, cmdCorrect, cmdErrmsg, cmdExecuted);

	OmnTCTrue(executionRslt) << "Failed to run command: " 
		<< cmd << ". Execution Error Message: " << mExecutionErrmsg
		<< endtc;

	if (!executionRslt) cmdFailedStat(mId);
	if (cmdExecuted) 
	{
		cmdExecutedStat(mId);
		logCmd(cmd, cmdCorrect, cmdErrmsg, cmdId);
	
		if (cmdCorrect)
		{
			aos_assert_r(doCorrectPostActions(), false);
		}
		else
		{
			aos_assert_r(doIncorrectPostActions(), false);
		}
	}

	u32 crtCmdId = cmdId++;

	// 
	// Ready to run post semantics now. But make sure that it
	// will not run the semantics unless the command was actually
	// executed.
	//
	bool actual = true;
	if (executionRslt && cmdExecuted)
	{
		aos_assert_r(doPostSemantics(cmdCorrect, cmdErrmsg), false);
	}

	if (!executionRslt)
	{
		OmnTCTrue(false) << "Execution failed. Errmsg: " 
			<< mExecutionErrmsg 
			<< ". Cmd: " << cmd << ". CmdId: " << crtCmdId << endtc;
		cmdFailedStat(mId);
	}
	else if (cmdCorrect != actual)
	{
		cmdFailedStat(mId);
		if (cmdCorrect)
		{
			OmnTCTrue(false) << "Expecting success but "
				<< "actual failed. CmdID: " 
				<< crtCmdId << ". Command: " << cmd 
				<< ". CmdId: " << crtCmdId 
				<< ". Errmsg: " << cmdErrmsg << endtc;
		}
		else
		{
			OmnTCTrue(false) << "Mismatch found: Expecting failed but "
				<< "actual success. CmdID: "
				<< crtCmdId << ". Function: " << cmd 
				<< ". CmdId: " << crtCmdId
				<< ". Errmsg: " << cmdErrmsg << endtc;
		}
		mTorturer->printTables();
	}

	return true;
}


// 
// Description:
// The function determines whether to select an object from
// its object table and construct the command based on the
// object. 
//
// correctFlag (IN):
// 		It indicates whether to generate a correct, incorrect, 
// 		or random object.
//
// tableSelected (OUT):
// 	 	If an object is selected from a table (either mCorrectTable
// 	 	or mIncorrectTable), this parm holds the table.
//
// selectFromObj(OUT): 
// 		If an object is selected, this parameter is set to true.
// 		Otherwise, it is set to false.
//
// cmdCorrect(OUT): 
// 		It indicates whether the generated command is correct 
// 		(true) or not (false).
//
// Return:
// 		The function always return true unless there are 
// 		program errors.
//
bool
AosCommand::selectObject(
		const AosCorCtrl::E expectedCorrectness,
		AosRecord &record, 
		AosTablePtr &tableSelected,
		bool &cmdCorrect, 
		bool &possible) 
{
	tableSelected = 0;
	record.clear();
	possible = true;

	switch (expectedCorrectness)
	{
	case AosCorCtrl::eCorrectOnly:
	case AosCorCtrl::eCorrectIfPossible:
		 aos_assert_r(selectFromTable(mCorrectTable, record, 
				false), false);
		 if (!record.isEmpty())
		 {
			 // 
			 // The command should be generated by object that is
			 // randomly selected from mCorrectTable.
			 //
			 cmdCorrect = true;
		 }

		 if (expectedCorrectness == AosCorCtrl::eCorrectOnly) 
		 {
			 possible = false;
		 }
		 return true;

	case AosCorCtrl::eIncorrectOnly:
	case AosCorCtrl::eIncorrectIfPossible:
		 // 
		 // Need to create an incorrect command. Whether an 
		 // incorrect command must be created based on a
		 // record from mIncorrectTable or not is
		 // depended on whether it is null. If not null, 
		 // we will randomly determine whether to select from
		 // it or generate an incorrect command syntactically.
		 //
		 cmdCorrect = false;
		 aos_assert_r(selectFromTable(mIncorrectTable, record,
				false), false);
		 if (!record.isEmpty())
		 {
			 // 
			 // The command should be generated from the table.
			 //
			 cmdCorrect = false;
		 }

		 if (expectedCorrectness == AosCorCtrl::eIncorrectOnly) 
		 {
			 possible = false;
		 }
		 return true;

	case AosCorCtrl::eRandom:
		 // 
		 // Generate command randomly
		 //
		 if (aos_next_pct(mCorrectPct))
		 {
			 // 
			 // Select from mCorrectTable 
			 //
			 aos_assert_r(selectFromTable(mCorrectTable, record,
					true), false);
			 if (!record.isEmpty())
			 {
				 cmdCorrect = true;
				 return true;
			 }
		 }

		 // 
		 // Select from mIncorrectTable
		 //
		 aos_assert_r(selectFromTable(mIncorrectTable, record, 
				true), false);
		 if (!record.isEmpty())
		 {
			 cmdCorrect = false;
		 }
		 return true;

	default:
		 OmnAlarm << "Unrecognized correctFlag: " 
			 << expectedCorrectness << enderr;
		 return false;
	}

	aos_should_never_come_here;
	return false;
}


// 
// Description:
// The purpose of this function is to determine whether
// to generate the command by selecting a record from 
// the table. If yes, 'record' holds the selected record, 
// Otherwise, the command shall be created on its own. It sets 
// 'record = null'. If it must select from table
// but the table is empty, notPossible = true. If 'isRandom'
// is false, if the table is not empty, it will always
// choose from the table. If 'isRandom' is true, whether
// to choose a record from the table or not is determined
// by the randomness of the table.
//
// Return Value:
// It returns false only when there are program errors.
// Otherwise, it always returns true.
//
// When it returns true, the following is passed back:
// 	record: either null or the record selected
// 	notPossible:   either true of false. If true, record 
// 				   should be null. 
// 
bool
AosCommand::selectFromTable(
		const AosTablePtr &table, 
		AosRecord &record, 
		const bool isRandom)
{
	if (!table || table->isEmpty()) return true;
	
	if (!isRandom)
	{
		aos_assert_r(table->randomGetRecord(record), false);
		return true;
	}

	if (table->getSelectPct() == 100 ||
		aos_next_pct(table->getSelectPct()))
	{
		//
		// This means we should enerate the command
		// from the table. If the table is empty (checked
		// below), it is not possible.
		//
		aos_assert_r(table->randomGetRecord(record), false);
		return true;
	}

	// 
	// Should not select from the table
	//
	return true;
}


/*
AosCorCtrl::E
AosCommand::calculateCorrectCtrl(const AosCorCtrl::E c)
{
	if (c == AosCorCtrl::eCorrectOnly ||
		c == AosCorCtrl::eIncorrectOnly) 
	{
		return c;
	}

	if (mCorrectPct > 100 || mCorrectPct < 0)
	{
		OmnAlarm << "Invalid percentage: " << mCorrectPct << enderr;
		return AosCorCtrl::eCorrect;
	}
	return (aos_next_pct(mCorrectPct) ? 
			AosCorCtrl::eCorrect: 
			AosCorCtrl::eIncorrect);
}
*/


bool
AosCommand::isPossible(
		const AosCorCtrl::E expected, 
		const bool actual) const
{
	return !(expected == AosCorCtrl::eCorrectOnly && !actual ||
			 expected == AosCorCtrl::eIncorrectOnly && actual );
}


bool
AosCommand::isObjectTableEmpty() const
{
	// 
	// The function returns true if the Object Table is null
	// or it is empty.
	//
//	return (!mSemanticData || mSemanticData->isTableEmpty(sgObjectTableName));
	return true;
}


bool
AosCommand::doPreSemantics(
		bool &cmdCorrect, 
		std::string &theErrmsg)
{
	std::string errmsg;
	int ret = AosEvaluateSemanticRules(mPreSemanticRules, 
		mSemanticData, errmsg);
	switch (ret)
	{
	case eAosRc_RuleEvaluateTrue:
		 return true;

	case eAosRc_RuleEvaluateFalse:
		 // 
		 // Semantics evaluated false. This means the command
		 // should be incorrect.
		 //
		 cmdCorrect = false;
		 theErrmsg += errmsg;
		 return true;

	default:
		 // 
		 // Errors were encountered or the semantic rules failed
		 // the evaluation and they demand abort the execution.
		 //
		 OmnAlarm << "Failed the pre-semantics: " << errmsg << enderr;
		 return false;
	}

	aos_should_never_come_here;
	return false;
}


int
AosCommand::doPostSemantics(
		bool &actual, 
		std::string &theErrmsg)
{
	std::string errmsg;
	int ret = AosEvaluateSemanticRules(mPostSemanticRules, 
			mSemanticData, errmsg);
	actual = true;
	switch (ret)
	{
	case eAosRc_RuleEvaluateTrue:
		 // 
		 // Rules are evaluated true. 
		 //
		 return true;

	case eAosRc_RuleEvaluateFalse:
		 // 
		 // Rules were evaluated false. This changes the 
		 // command status to incorrect. 
		 //
		 actual = false;
		 theErrmsg += errmsg;
		 return true;

	default:
		 // 
		 // Errors were encountered or the semantic rules failed
		 // the evaluation and they demand abort the execution.
		 //
		 OmnAlarm << "Failed the post-semantics: " << errmsg << enderr;
		 return false;
	}

	aos_should_never_come_here;
	return false;
}


bool
AosCommand::doCorrectPreActions()
{
	std::string errmsg;
	int ret = AosAction_doActions(mPreCorrectActions, 
				mSemanticData, mActionData, errmsg);
	if (!ret) return true;

	OmnAlarm << "Failed to run actions: " << errmsg << enderr;
	return false;
}


bool
AosCommand::doIncorrectPreActions()
{
	std::string errmsg;
	int ret = AosAction_doActions(mPreIncorrectActions, 
				mSemanticData, mActionData, errmsg);
	if (!ret) return true;

	OmnAlarm << "Failed to run actions: " << errmsg << enderr;
	return false;
}


bool
AosCommand::doCorrectPostActions()
{
	std::string errmsg;
	int ret = AosAction_doActions(mPostCorrectActions, 
				mSemanticData, mActionData, errmsg);
	if (!ret) return true;

	OmnAlarm << "Failed to run actions: " << errmsg << enderr;
	return false;
}


bool
AosCommand::doIncorrectPostActions()
{
	std::string errmsg;
	int ret = AosAction_doActions(mPostIncorrectActions, 
				mSemanticData, mActionData, errmsg);
	if (!ret) return true;

	OmnAlarm << "Failed to run actions: " << errmsg << enderr;
	return false;
}


bool 
AosCommand::readFromFile()
{
	if (mProductName.empty() || mCmdName.empty())
	{
		OmnAlarm << "The command name is empty, please set it." << enderr;
		return false;
	}
	std::string configFile;
	if (!AosConfigMgr::getConfigFileName(mProductName, AosConfigMgr::eCommand, mCmdName, configFile))
	{
		return false;
	}
	return readFromFile(configFile);
}


bool 
AosCommand::writeToFile()
{
	if (mCmdName.empty())
	{
		OmnAlarm << "The command name is empty, please set it." << enderr;
		return false;
	}
	std::string configFile;
	if (!AosConfigMgr::getConfigFileName(mProductName, AosConfigMgr::eCommand, mCmdName, configFile))
	{
		return false;
	}
	return writeToFile(configFile);
}


bool 
AosCommand::readFromFile(const std::string& configFile)
{
	TiXmlDocument doc(configFile);
	if (!doc.LoadFile())
	{
		OmnAlarm << "There is no this config file in the command directory: "
		   		<< configFile
				<< enderr;
		return false;
	}
	TiXmlElement* element = doc.FirstChildElement();
	if (!element)
	{
		OmnAlarm << "There is no command definition in the config file" << enderr;
		return false;
	}
	if (!deserialize(element))
	{
		return false;
	}
	return true;
}


bool 
AosCommand::writeToFile(const std::string& configFile)
{
	TiXmlDocument doc(configFile);
	TiXmlElement element("");
	if (!serialize(element))
	{
		return false;
	}
	doc.InsertEndChild(element);
	doc.SaveFile();
	return true;
}


std::string 
AosCommand::getName() const
{
	return mCmdName;
}


void 
AosCommand::setName(const std::string& name)
{
	mCmdName = name;
}


std::string 
AosCommand::getProductName() const
{
	return mProductName;
}


void 
AosCommand::setProductName(const std::string& name)
{
	mProductName = name;
}


bool 
AosCommand::commandFactory(std::string configFile, AosCommandPtr& cmd)
{
	TiXmlDocument doc(configFile);
	if (!doc.LoadFile())
	{
		OmnAlarm << "There is no command config file in the command directory: " 
				<< configFile
				<< enderr;
		return false;
	}
	TiXmlElement* element = doc.FirstChildElement();
	if (!element)
	{
		OmnAlarm << "There is no command definition in the config file" 
				<< configFile
				<< enderr;
		return false;
	}
	if (element->ValueStr() == "Func")
	{
		cmd = OmnNew AosFuncCmd();	
	}
	else if (element->ValueStr() == "Cli")
	{
		cmd = OmnNew AosCliCmd();	
	}
	cmd->readFromFile(configFile);
	return true;
}


void
AosCommand::logCmd(const std::string &cmd, 
						  const bool isCorrect, 
						  const std::string &errmsg, 
						  const u32 cmdId)
{
	std::string str;

	if (isCorrect)
	{
		str = "Command(y): ";
		str += AosValue::itoa(cmdId);
	   	str += " \"";
		str += cmd + "\"\n";
	}
	else
	{
		str = "Command(n): ";
	   	str += AosValue::itoa(cmdId);
	   	str += " \"";
		str += cmd + "\". Errmsg: " + errmsg + "\n";
	}

	mLogType = AosTorturer::getLogType();
	switch (mLogType)
	{
		case AosTorturerLogType::eNoLog:
			 break;

		case AosTorturerLogType::eOnScreen:
		 	std::cout << str << std::endl;
		 	break;

		case AosTorturerLogType::eFile:
			if (!mLogFile)
			{
				// 
				// Ignore the logging
				//
				break;
			}
			mLogFile->append(cmd.c_str(), true);
			break;

		default:
			OmnAlarm << "Unrecognized log type: " << mLogType << enderr;
			break;
	}
}


bool		
AosCommand::setLogfile(const OmnFilePtr &file)
{
	mLogFile = file;

	if (!file) return true;
	
	std::string str;
	str = "#include \"aosUtil/Types.h\"\n";
	str	+= "#include \"Debug/Debug.h\"\n";
	str	+= "#include \"Util/String.h\"\n";

	int sgFuncIndex = AosTorturer::getNextFuncIndex();
	std::list<std::string> includes;
	AosTorturer::getLogIncludes(includes);
	std::list<std::string>::iterator iter;
	for (iter=includes.begin(); iter!=includes.end(); iter++)
	{
		str += *iter + "\n";
	//	str += "extern int func_torturer_special_case";
	//	str += AosValue::itoa(sgFuncIndex + 1);
	// 	str += "();\n";
		sgFuncIndex = AosTorturer::getNextFuncIndex();
	}

	if (sgFuncIndex == 1)
	{
		str += "\nbool func_torturer_special_case() \n";
		str += "{\n";
		str += "    ";
	  	str += AosTorturer::getInitFuncs() + "\n\n";
	}
	else
	{
		str += "\nbool func_torturer_special_case";
	  	str += AosValue::itoa(sgFuncIndex);
		str += "() \n{\n";
	}

	mLogFile->append(str.c_str(), false);
	return true;
}


AosVarPtr
AosCommand::getVar(const std::string &name)
{
	aos_not_implemented_yet;
	return 0;
}


AosValuePtr
AosCommand::getValue(const std::string &name)
{
	aos_not_implemented_yet;
	return 0;
}


AosTablePtr
AosCommand::getTable(const std::string &name)
{
	aos_not_implemented_yet;
	return 0;
}


