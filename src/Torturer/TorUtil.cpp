////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
//   
//
// Modification History:
// Wednesday, January 09, 2008: Created by Allen Xu 
//
////////////////////////////////////////////////////////////////////////////


#include "Torturer/TorUtil.h"
#include "Porting/GetTime.h"
#include "Alarm/Alarm.h"
#include "Debug/Debug.h"
#include "ProgramAid/Util.h"
#include "RVG/ConfigMgr.h"
#include "Util/File.h"
#include "RVG/CommonTypes.h"

static const char* sgTorturerLogTypeNames[AosTorturerLogType::eLastEntry] =
{
	"NoLog",
	"OnScreen",
	"File",
};


std::string 
AosTorturerLogType::enum2Str(const AosTorturerLogType::E type)
{
	if (type < 0 || type >= AosTorturerLogType::eLastEntry)
	{
		return "NoLog";
	}

	return sgTorturerLogTypeNames[type];
}


AosTorturerLogType::E 
AosTorturerLogType::str2Enum(const std::string& name)
{
	int i=0;
	for (i=0; i<AosTorturerLogType::eLastEntry; i++)
	{
		if (name == std::string(sgTorturerLogTypeNames[i]))
		{
			return (AosTorturerLogType::E)i;
		}
	}
	return AosTorturerLogType::eNoLog;
}


static std::string sgSourceFileHeader = 
"//////////////////////////////////////////////////////////////////////////\n"
"//\n"
"// Copyright (C) 2005\n"
"// Packet Engineering, Inc. All rights reserved.\n"
"//\n"
"// Redistribution and use in source and binary forms, with or without\n"
"// modification is not permitted unless authorized in writing by a duly\n"
"// appointed officer of Packet Engineering, Inc. or its derivatives\n"
"//\n"
"// Description:\n"
"// This file is automatically generated by the TorturerGen facility. \n"
"//\n"
"// Modification History:\n";


static std::string sgCreationDate = "<$$CreationDate>";
static std::string sgTargetName = "<$$TargetName>";
static std::string sgTestSuiteName = "<$$TestSuiteName>";
static std::string sgTestSuiteHeader = "<$$TestSuiteHeaderFile>";
static std::string sgDots = "<$$DOTS>";
static std::string sgPlatformPath = "<$$PATH>";
static std::string sgAosPath = "<$$AOSHOME>";


std::string 
AosTorturerUtil::aos_get_file_declaimer()
{
	std::string str = sgSourceFileHeader;
	str += "// ";
   	str += OmnGetMDY().data();
	str += " Created by TorturerGen Facility\n";
	str += "//////////////////////////////////////////////////////////////////////////\n";
	return str;
}


std::string 
AosTorturerUtil::aos_get_header_guard(const std::string &srcDirName, 
			const std::string &testDirName, 
			const std::string &className)
{
	std::string name = "Aos_";
	name += srcDirName;
   	name += "_" + testDirName;
   	name += "_" + className + "_h\n";
	std::string str = "#ifndef ";
	str += name + "#define " + name + "\n";
	return str;
}


bool
AosTorturerUtil::createMakefile(const std::string &srcDir, 
							   const std::string &testDir,
							   const std::string &targetName,
							   const bool force, 
							   const AosMakefileType type)
{
	std::string dirname = srcDir;
	if (!testDir.empty())
	{
		dirname += "/" + testDir;
	}

	std::string platformDir;
	if (!AosConfigMgr::getPlatformDir(platformDir))
	{
		return false;
	}

	std::string filename;
  	filename +=	dirname + "/Makefile";

	if (!force && OmnFile::fileExist(filename.c_str()))
	{
		// 
		// The file is there. Do nothing.
		//
		return true;
	}

	// 
	// Copy the Makefile template to the new location
	//
	std::string cmd = "cp -f ";
	std::string makefileName;
	switch (type)
	{
	case eAosMakefileType_Exe:
		 makefileName = "MakefileForExe";
		 break;
	
	case eAosMakefileType_Lib:
		 makefileName = "MakefileForLib";
		 break;

	default:
	     OmnAlarm << "Invalid makefile type: " << type << enderr;
		 return false;
	}

	cmd += platformDir;
   	cmd += "/CodeTemplate/" + makefileName;
   	cmd += " " + filename;

	system(cmd.c_str());

	std::string homedir = AosProgramAid_getAosHomeDir().data();
	if (homedir == "")
	{
		OmnAlarm << "AOS_HOME environment variable not set. "
			<< "This environment variable should point to AOS src directory!"
			<< enderr;
		return false;
	}

	// 
	// Open the Makefile template
	//
	OmnFile file(filename.c_str(), OmnFile::eReadOnly);
	if (!file.isGood())
	{
		OmnAlarm << "Failed to open the Makefile template: " 
			<< filename << enderr;
		return false;
	}

	std::string exename = targetName;
	bool ret = file.replace(sgCreationDate.c_str(), OmnGetMDY(), false);
	if (!ret)
	{
		OmnAlarm << "Failed to replace date" << enderr;
		return false;
	}

	if (!(ret = file.replace(sgTargetName.c_str(), exename.c_str(), false)))
	{
		OmnAlarm << "Failed to replace TargetName: " 
			<< filename << ":" << sgTargetName << ":" << exename << enderr;
		return false;
	}

	if (!(ret = file.replace(sgAosPath.c_str(), homedir.c_str(), true)))
	{
		OmnAlarm << "Failed to replace dots" << enderr;
		return false;
	}

	if (!(ret = file.replace(sgPlatformPath.c_str(), platformDir.c_str(), true)))
	{
		OmnAlarm << "Failed to replace dots" << enderr;
		return false;
	}

	file.flushFileContents();
	return true;
}


bool
AosTorturerUtil::createMain(const std::string &srcDir, 
						   const std::string &testDir,
						   const std::string &targetName,
						   const AosCodeGenMainType type,
						   const bool force)
{
	std::string dirname = srcDir;
	if (!testDir.empty())
	{
		dirname += "/" + testDir;
	}


	std::string platformDir;
	if (!AosConfigMgr::getPlatformDir(platformDir))
	{
		return false;
	}

	std::string filename;
   	filename += dirname + "/main.cpp";

	if (!force && OmnFile::fileExist(filename.c_str()))
	{
		// 
		// The file is there. Do nothing.
		//
		return true;
	}

	std::string mainName = platformDir;
	switch (type)
	{
	case eAosCodeGenMainType_Normal:
		 mainName += "/CodeTemplate/main_normal";
		 break;

	case eAosCodeGenMainType_CliTorturer:
		 mainName += "/CodeTemplate/main_with_cli";
		 break;

	case eAosCodeGenMainType_FuncTorturer:
		 mainName += "/CodeTemplate/main_func_torturer";
		 break;

	default:
		 OmnAlarm << "Unrecognized main type: " << type << enderr;
		 return false;
	}

	if (!OmnFile::fileExist(mainName.c_str()))
	{
		cout << "The main.cpp template file does not exist. You need "
			 << "check the file out by going to \"Data/torturerGen\""
			 << " sub-directory and running the cvs command "
			 << "\"cvs update\"" << endl;
		return false;
	}

	std::string cmd = "cp -f ";
	cmd += mainName;
   	cmd += " " + filename;
	system(cmd.c_str());

	// 
	// Open the main.cpp template
	//
	OmnFile file(filename.c_str(), OmnFile::eReadOnly);
	if (!file.isGood())
	{
		OmnAlarm << "Failed to open the main template: " 
			<< filename << enderr;
		return false;
	}

	std::string className = "Aos";
	className += targetName;
   	className += "TestSuite";
	std::string headerFile = dirname;
	headerFile += "/TestSuite.h";

	bool ret = file.replace(sgCreationDate.c_str(), OmnGetMDY(), false);
	switch (type)
	{
	case eAosCodeGenMainType_Normal:
	case eAosCodeGenMainType_CliTorturer:
		 ret = ret && file.replace(sgTestSuiteName.c_str(), className.c_str(), false) &&
		   	   file.replace(sgTestSuiteHeader.c_str(), headerFile.c_str(), false);
		 break;

	case eAosCodeGenMainType_FuncTorturer:
	     ret = ret && file.replace(sgTargetName.c_str(), targetName.c_str(), false);
		 break;

	default:
		 OmnAlarm << "Unrecognized main type: " << type << enderr;
		 return false;
	}

	if (!ret)
	{
		OmnAlarm << "Failed to create main.cpp" << enderr;
		return false;
	}

	file.flushFileContents();
	return true;
}
