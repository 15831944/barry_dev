///////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility. 
//
// Modification History:
// 4/12/2007 Created by TorturerGen Facility
//////////////////////////////////////////////////////////////////////////
#include "InetCtrl/Tester/IacTester.h"

#include "Debug/Debug.h"
#include "InetCtrl/Tester/InetCliTester.h"
#include "Tester/Test.h"
#include "Tester/TestMgr.h"
#include "Thread/Mutex.h"
#include "Util/OmnNew.h"
#include "Util/IpAddr.h"
//#include "Util/Random.h"
#include "Random/RandomUtil.h"
#include "StreamSimu/StreamSimuMgr.h"
#include "StreamSimu/StreamSimuEntry.h"
#include "Porting/Sleep.h" 

#include "UtilComm/ConnBuff.h"
#include "UtilComm/TcpClient.h"

#include <netinet/in.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
// 
// Connection creation selector definition
//
static OmnString sgConnCreationSelectorDef = 
        "<Elements>"
            "<Element>1,  15</Element>"   //  
            "<Element>2,  15</Element>"   //  
            "<Element>3,  10</Element>"   //  
            "<Element>4,  60</Element>"   //  
        "</Elements>";



const int eStartLocalPort = 10000; 
const int eEndLocalPort = 20000;
static bool sgLocalPorts[eEndLocalPort - eStartLocalPort + 1];


AosIacTester::stream::stream()
:
sip(0),
sport(0),
dip(0),
dport(0),
startTime(0),
endTime(0)
{
}

AosIacTester::stream::~stream()
{
}

AosIacTester::stream& AosIacTester::stream::operator = (const AosIacTester::stream &stm)
{
	sip			= stm.sip;
	sport		= stm.sport;
	dip			= stm.dip;
	dport		= stm.dport;
	protocol	= stm.protocol;
	startTime	= stm.startTime;
	endTime		= stm.endTime;
	
	return *this;
}

void
AosIacTester::stream::clear()
{
	sip 	= 0;
	sport 	= 0;
	dip 	= 0;
	dport	= 0;
	protocol = "";
	startTime = 0;
	endTime = 0;
}

AosIacTester::AosIacTester()
:
mCliTorturer(OmnNew AosInetCliTester()),
mStreamNum(0)
{
	memset(sgLocalPorts, 0, sizeof(sgLocalPorts));
}


AosIacTester::~AosIacTester() 
{
}


bool
AosIacTester::start()
{
	init();
	basicTest();
	return true;	
}

bool
AosIacTester::basicTest()
{
	int loopWithRunCLIs = RAND_INT(2000,2000);
    for(int i = 0;i < loopWithRunCLIs;i++)
    {
		u32 cliCount = RAND_INT(eMinCliCount,eMaxCliCount);
    	mCliTorturer->basicTest(cliCount);		
    	mCliTorturer->printfAll();		
//        	int procStreamInterval = RAND_INT(1,eMaxProcStreamInterval);
       	procStreams();
//      setSystemTime();
//		int checkInterval = 5; 
        // OmnSleep(procStreamInterval);
        OmnSleep(5);
        	
        int loopWithResultCheck = RAND_INT(5,5);
//		int checkInterval = RAND_INT(1,eMaxCheckInterval);
		for (int k=0; k<loopWithResultCheck; k++)
		{
			setSystemTime();
			OmnSleep(15);
			checkResult();
			OmnSleep(10);
		}
		
		clearAll();
		OmnSleep(30);
	}
	
	return true;	
}

bool
AosIacTester::procStreams()
{
	//
	//proc streams
	//	
	
	int loopWithProcStreams = RAND_INT(80,80);
    for(int j = 0;j < loopWithProcStreams;j++)
	{
		if(PERCENTAGE(100) && (mStreamNum < eMaxStream))
		{
			addStream();
		}
		else if(mStreamNum > 0)
		{
			removeStream();	
		}
	}
	
	return true;	
}


bool
AosIacTester::addStream()
{
		
	int sel = mConnCreationSelector->nextInt();
	bool ret;
	switch (sel)
	{
	case 1:
		 ret = createConnOnlyHitGroup();
		 break;
 
	case 2:
	 	 ret = createConnOnlyHitApp();
		 break;

	case 3: 
		 ret = createConnNotHitGroupApp();
		 break;

	case 4: 
		 ret = createConnHitGroupApp();
		 break;

	default:
		 OmnAlarm << "Unrecognized selection: " << sel << enderr;
		 return false;
	}

	return ret;
	
}	

bool
AosIacTester::removeStream()
{
	int index = RAND_INT(0, mStreamNum-1);
		
	AosStreamSimuMgr::getSelf()->removeStream(mStreamList[index].protocol,
    									      mStreamList[index].sip,
    									      mStreamList[index].sport,
    									      mStreamList[index].dip,
    									      mStreamList[index].dport);
	
	delFromStreamList(index);
	return true;
	
}

bool
AosIacTester::removeAllStream()
{
	for(int i = 0 ; i < mStreamNum ; i++)
	{	
		AosStreamSimuMgr::getSelf()->removeStream(mStreamList[i].protocol,
    										      mStreamList[i].sip,
    										      mStreamList[i].sport,
    										      mStreamList[i].dip,
    									    	  mStreamList[i].dport);
	
	}
	
	return true;
}

bool
AosIacTester::removeAllBouncer()
{
	OmnString cmd = "";
	
	for(int i = 0 ; i < mStreamNum ; i++)
	{	
		cmd = "bouncer mgr remove bouncer ";
		cmd << mStreamList[i].protocol << " " 
	        << OmnIpAddr(mStreamList[i].sip).toString() << " " 
	   		<< mStreamList[i].sport << " " 
	    	<< OmnIpAddr(mStreamList[i].dip).toString() << " "
	    	<< mStreamList[i].dport;
cout << cmd << endl;
		sendCmd(cmd, mBouncerConn);
//		if(!sendCmd(cmd,mBouncerConn))
//		{	
//			return false;
//		}			
	}
	
	return true;
}

bool
AosIacTester::clearAll()
{
	removeAllStream();	
	removeAllBouncer();
	mStreamNum = 0;
}

bool
AosIacTester::createConnOnlyHitGroup()
{
	//
	//Create a not in group connection
	//
	
	u32 sip,dip;
	int sport,dport;
	OmnString protocol;
	
	
	if(mCliTorturer->onlyHitGroup(sip) == false)
	{
		getRandomParms(sip, sport, dip, dport, protocol);
	}
//	sip = getRandomSip();
	sport = getRandomPort();
	dip = getRandomDip();
	dport = getRandomPort();
	protocol = getRandomProto();

	addConn(sip, sport, dip, dport, protocol);
		
	return true;
}

bool
AosIacTester::createConnOnlyHitApp()
{
	//	
	//Random generate not hit application connection
	//
	
	u32 sip,dip;
	int sport,dport;
	OmnString protocol;
	
	sip = getRandomSip();
	sport = getRandomPort();
	
	if(mCliTorturer->onlyHitApp(dip, dport, protocol) == false)
	{
		getRandomParms(sip, sport, dip, dport, protocol);
	}

	addConn(sip, sport, dip, dport, protocol);

	return true;
	
}

bool
AosIacTester::createConnNotHitGroupApp()
{
	//
	//
	//
	
	u32 sip,dip;
	int sport,dport;
	OmnString protocol;
	
	sport = getRandomPort();
	
	if(mCliTorturer->notHitGroupApp(sip, dip, dport, protocol) == false)
	{
		getRandomParms(sip, sport, dip, dport, protocol);
	}

	addConn(sip, sport, dip, dport, protocol);

	return true;		
}

bool
AosIacTester::createConnHitGroupApp()
{
	//
	//
	//
	u32 sip,dip;
	int sport,dport;
	OmnString protocol;
	
	sport = getRandomPort();

//	mCliTorturer->hitGroupApp(sip, dip, dport, protocol);
	
	if(mCliTorturer->hitGroupApp(sip, dip, dport, protocol) == false)
	{
		getRandomParms(sip, sport, dip, dport, protocol);
	}

	addConn(sip, sport, dip, dport, protocol);

	return true;
}


bool
AosIacTester::addConn(u32 &sip, int &sport, u32 &dip, int &dport, OmnString &protocol)
{
	if(connExist(sip, sport, dip, dport, protocol) == 1)
	{
		return false;	
	}
	
//	int bandwidth = RAND_INT(128, eMaxBandwidth);
	int bandwidth = RAND_INT(5000,10000);
	int packetSize = RAND_INT(64, eMaxPacketSize);
	int streamType = RAND_INT(1,1);
	int maxBw = RAND_INT(65, 128);
	int minBw = RAND_INT(1, 64);
	
	//add bouncer	
	addBouncer(sip, sport, dip, dport, protocol);
	
	//add stream
	AosStreamSimuMgr::getSelf()->addStream(protocol, OmnIpAddr(sip), sport, OmnIpAddr(dip), dport, bandwidth,
								packetSize, (AosStreamType::E)streamType, maxBw, minBw);
								
	u32 startTime = getStartTime();

	//save to structure
	saveToStreamList(sip, sport, dip, dport, protocol, startTime);
	
	return true;	
}


int
AosIacTester::connExist(u32 &sip, int &sport, u32 &dip, int &dport, OmnString &protocol)
{
	for(int i = 0;i < mStreamNum-1; i++)
	{
		if((mStreamList[i].sip == sip && mStreamList[i].sport == sport)	&&
		   (mStreamList[i].dip == dip && mStreamList[i].dport == dport))
		{
			return 1;	
		}
	}
	
	return 0;
}

bool
AosIacTester::getRandomParms(u32 &sip, int &sport, u32 &dip, int &dport, OmnString &protocol)
{
	sip = getRandomSip();
	sport = getRandomPort();
	dip = getRandomDip();
	dport = getRandomPort();
	protocol = getRandomProto();

	return true;
}

bool
AosIacTester::checkResult()
{
	//
	//
	//

//cout << "the streamNum is : " << mStreamNum << endl;		
	for(int i = 0; i <= mStreamNum-1;i++)
	{
		OmnString checkTime = getCheckTime();
//cout << "check time is " << checkTime << endl;
		bool expected = mCliTorturer->isConnPass(mStreamList[i].sip,
   	 						 mStreamList[i].sport,
    						 mStreamList[i].dip,
    				         mStreamList[i].dport,
    				         mStreamList[i].protocol,
    				         checkTime);

		long crtBw = getCrtBw(i);
		
		OmnString rslt;
		rslt<< "expect is: " << expected << " " 
			<< "crtBw: " << crtBw << ":" << i << " "
			<< ":" << mStreamList[i].protocol << " " 
			<< ":" << OmnIpAddr(mStreamList[i].sip).toString() << " "
			<< ":" << OmnIpAddr(mStreamList[i].dip).toString() << " " 
			<< ":" << mStreamList[i].sport << " "
			<< ":" << mStreamList[i].dport << "\n";
//cout << "*****************************************" <<endl;
//cout << rslt ;
//cout << "*****************************************" <<endl;
		

		//set TC depend on ret and crtBw
		if (expected)
		{
cout << rslt << endl;
			OmnTCTrue(crtBw > 0) << rslt << endtc;
		}
		else
		{
cout << rslt << endl;
			OmnTCTrue(crtBw == 0) << rslt << endtc;
		}
	}
	
	return true;
}


/////////////Facilities/////////////////

u32
AosIacTester::genInRangeIp(const OmnIpAddr &netaddr, const OmnIpAddr &netmask)
{
	//
	//Generate an IP in subnet(netaddr, netmask)
	//
	
	u32 n = netaddr.getIPv4();
	u32 m = netmask.getIPv4();

	OmnIpAddr ip = OmnIpAddr(htonl(aos_next_int(0, ntohl(INT_MAX & ~m)) + ntohl(n & m)));
	return ip.toInt();
}

u32
AosIacTester::getRandomSip()
{
	//
	//Random generate an IP in the IP range that defined by IpProxy
	//
	u32 localIP = genInRangeIp(OmnIpAddr(mLocalIpRange), OmnIpAddr(mLocalNetmask));
	
	return localIP;	
}


u32
AosIacTester::getRandomDip()
{
	//
	//Random generate an IP in the IP range that defined by IpProxy
	//	
	u32 remoteIP = genInRangeIp(OmnIpAddr(mRemoteIpRange), OmnIpAddr(mRemoteNetmask));
	
	return remoteIP;	
}



int
AosIacTester::getRandomSport()
{
	//
	//Random get a sport that not bound
	//
	
	
	int index = RAND_INT(eStartLocalPort, eEndLocalPort);

	while(sgLocalPorts[index])
	{
 		int index = RAND_INT(eStartLocalPort, eEndLocalPort);
 	}	
	
	sgLocalPorts[index] = false;
	return index;	
	
}


int
AosIacTester::getRandomDport()
{
	//
	//Randomly generate a dst port in(eMinDport, eMaxDport)
	//
	int dport = RAND_INT(eMinDport, eMaxDport);
	return dport;	
}

int
AosIacTester::getRandomPort()
{
	int port = RAND_INT(4000,8000);	
	return port;
}

OmnString
AosIacTester::getRandomProto()
{
	//
	//Random generate protocol from "tcp" and "udp"
	//
	
	OmnString protocols[2];
	protocols[0] = "tcp";
	protocols[1] = "udp";
	
	int index = RAND_INT(0,0);
	
	return protocols[index];	
	
}


bool
AosIacTester::saveToStreamList(u32 &sip, int &sport, u32 &dip, 
							   int &dport, OmnString &protocol,
							   u32 &startTime)
{
	mStreamList[mStreamNum].sip = sip;
	mStreamList[mStreamNum].sport = sport;
	mStreamList[mStreamNum].dip = dip;
	mStreamList[mStreamNum].dport = dport;
	mStreamList[mStreamNum].protocol = protocol;
	mStreamList[mStreamNum].startTime = startTime;
//	mStreamList[mStreamNum].endTime = endTime; 
	
	mStreamNum++;	
	
}

bool
AosIacTester::delFromStreamList(int index)
{
		
	// move stream list
    for(int i = index;i < mStreamNum - 1;i++)
    {
        mStreamList[i] = mStreamList[i+1];
    }
    mStreamList[mStreamNum-1].clear();
    mStreamNum --;
    return true;
	
}

bool
AosIacTester::setSystemTime()
{
	OmnString cmd = "system excute date -s ";
	OmnString time = "";
	OmnString date = "";
	
	int hour = RAND_INT(0,23);
	int minute = RAND_INT(0,59);
	int second = RAND_INT(0,59);
	
	time << hour << ":" << minute << ":" << second;
	
	int year = 2007;
	int month = RAND_INT(1,12);
	
	int day;
	if(month == 2)
	{
		day = RAND_INT(1,28);
	}
	else if(month == 1 || month == 3  || month == 5 || month == 7 ||
			month == 8 || month == 10 || month == 12)
	{
		day = RAND_INT(1,31);
	}
	else
	{
		day = RAND_INT(1,30);	
	}
		
	date << year << "-" << month << "-" << day;
	
	cmd << "\"" << time << " " << date << "\"";
cout << cmd << endl;
	OmnString rslt;	
	sendCmd(cmd, mRhcConn,rslt);
cout << rslt << endl;	

	return true;
}

bool
AosIacTester::addBouncer(u32 &sip, int &sport, 
						 u32 &dip, int &dport, 
						 OmnString &protocol)
{ 
  	OmnString cmd = "bouncer mgr add bouncer ";
    cmd << protocol << " " << OmnIpAddr(sip).toString() << " " 
    	<< sport  << " " << OmnIpAddr(dip).toString() << " " << dport;
      
    sendCmd(cmd,mBouncerConn);	
	
	return true;
}

bool
AosIacTester::sendCmd(const OmnString &cmd, const OmnTcpClientPtr &dstServer)
{
	OmnString strRslt;
	return sendCmd(cmd,dstServer,strRslt);
}


bool
AosIacTester::sendCmd(const OmnString &cmd,
					 const OmnTcpClientPtr &dstServer,
					 OmnString &strRslt)
{
	OmnString errmsg;
	OmnRslt rslt;
	
	int sec = 5;
	bool timeout = false;
	bool connBroken;
	
	if (!dstServer->isConnGood())
	{
		dstServer->closeConn();
		dstServer->connect(errmsg);
		if (!dstServer->isConnGood())
		{
			//alarm and return;
			OmnAlarm << "Failed to process connection" << rslt.getErrmsg() << enderr;
			return false;
		}
	}

	OmnString sendBuff = cmd;
	sendBuff << "\n\n";
	int sendLen = sendBuff.length();
	dstServer->writeTo(sendBuff, sendLen);

	OmnConnBuffPtr revBuff = new OmnConnBuff();
	if (!dstServer->readFrom(revBuff, sec,
						timeout, connBroken, false)||timeout)
	{
		//alarm and return
//        showCmd(cmd,revBuff);
        OmnAlarm << "cannot successfully get message from cli server: " 
			<< dstServer->toString() 
			<< ". Command: " << cmd 
			<< ". Errors: " << rslt.getErrmsg() << enderr;
        return false;
	}	
	if(revBuff && (! (*revBuff->getBuffer() == '\r' ||*revBuff->getBuffer() == '\n')))
    {
//       showCmd(cmd,revBuff);
    }

	strRslt.assign(revBuff->getBuffer(),revBuff->getDataLength());
    
	return true;
}

OmnString
AosIacTester::getCheckTime()
{
	OmnString cmd = "system excute date";
//	OmnString cmd = "system excute date";
	OmnString rslt;
	
	sendCmd(cmd, mRhcConn, rslt);
	
	return rslt;	
}

u32
AosIacTester::getStartTime()
{
	OmnString cmd = "system excute date +%s";
	OmnString rslt;
	
	sendCmd(cmd, mRhcConn, rslt);
	
	u32 crtTimeSec = rslt.toInt();
	return crtTimeSec;	
}


long 
AosIacTester::getCrtBw(const int streamNum)
{
	/*gen the command */
	OmnString cmd = "bouncer mgr get bandwidth ";
		
	cmd << mStreamList[streamNum].protocol << " "
	    << OmnIpAddr(mStreamList[streamNum].sip).toString()      << " "
	    << mStreamList[streamNum].sport    << " "
	    << OmnIpAddr(mStreamList[streamNum].dip).toString()      << " "
	    << mStreamList[streamNum].dport;
cout << cmd << endl;
	/*send command to bouncer*/    
	OmnString rslt;
	OmnString stringBw;
	
	sendCmd(cmd, mBouncerConn, rslt);
	
	int curPos = 0;
	for(int i = 0;i < 3;i++)
	{	
		curPos = rslt.getWord(curPos,stringBw);
	}
	long curBw = stringBw.toInt();	

	return curBw;
}

bool
AosIacTester::init()
{
	mLocalIpRange = "12.1.0.0";
	mLocalNetmask = "255.255.0.0";
	mRemoteIpRange = "11.1.0.0";
	mRemoteNetmask = "255.255.0.0";	
	
	mBouncer_Ip		= OmnIpAddr("172.22.155.123");
	mBouncer_Port	= 28000;                      
	mBouncerConn	= new OmnTcpClient("Bouncer",mBouncer_Ip,mBouncer_Port,1,OmnTcp::eNoLengthIndicator);
	
	
	mRhc_Ip			= OmnIpAddr("172.22.155.122");
	mRhc_Port		= 28000;
	mRhcConn		= new OmnTcpClient("Rhc",mRhc_Ip,mRhc_Port,1,OmnTcp::eNoLengthIndicator);

	mConnCreationSelector = OmnNew AosRandomInteger("mConnCreationSelector", 
    												 sgConnCreationSelectorDef,
    												 0);
	
	mCliTorturer->init();
	
	return true;
}


