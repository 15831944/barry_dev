package com.zykie.jdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.Ref;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Calendar;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import com.zykie.jdbc.utils.SQLError;
import com.zykie.jdbc.utils.ZykieLogger;
import com.zykie.jdbc.utils.Messages;
import com.zykie.jdbc.exceptions.ExceptionInterceptor;

/*
 *  A table of data representing a database result set, which is usually generated by 
 *  executing a statement that queries the database.
 *  
 *  A ResultSet object maintains a cursor pointing to its current row of data. Initially 
 *  the cursor is positioned before the first row. The next method moves the cursor to 
 *  the next row, and because it returns false when there are no more rows in the ResultSet 
 *  object, it can be used in a while loop to iterate through the result set.
 *  
 *  A default ResultSet object is not updatable and has a cursor that moves forward only. 
 *  Thus, you can iterate through it only once and only from the first row to the last row. 
 *  It is possible to produce ResultSet objects that are scrollable and/or updatable. 
 *  The following code fragment, in which con is a valid Connection object, illustrates 
 *  how to make a result set that is scrollable and insensitive to updates by others, and 
 *  that is updatable. See ResultSet fields for other options.
 *  
 *     Statement stmt = con.createStatement(
 *     ResultSet.TYPE_SCROLL_INSENSITIVE,
 *     ResultSet.CONCUR_UPDATABLE);
 *     ResultSet rs = stmt.executeQuery("SELECT a, b FROM TABLE2");
 *     // rs will be scrollable, will not show changes made by others,
 *     // and will be updatable
 *
 *
 * The ResultSet interface provides getter methods (getBoolean, getLong, and so on) for 
 * retrieving column values from the current row. Values can be retrieved using either 
 * the index number of the column or the name of the column. In general, using the column 
 * index will be more efficient. Columns are numbered from 1. For maximum portability, 
 * result set columns within each row should be read in left-to-right order, and each 
 * column should be read only once.
 * 
 * For the getter methods, a JDBC driver attempts to convert the underlying data to the 
 * Java type specified in the getter method and returns a suitable Java value. The JDBC 
 * specification has a table showing the allowable mappings from SQL types to Java types 
 * that can be used by the ResultSet getter methods.
 * 
 * The updater methods may be used in two ways:
 *  to update a column value in the current row. In a scrollable ResultSet object, the 
 *  cursor can be moved backwards and forwards, to an absolute position, or to a position
 *   relative to the current row. The following code fragment updates the NAME column in 
 *   the fifth row of the ResultSet object rs and then uses the method updateRow to update
 *    the data source table from which rs was derived.
 *    
 *         rs.absolute(5); // moves the cursor to the fifth row of rs
 *         rs.updateString("NAME", "AINSWORTH"); // updates the 
 *         // NAME column of row 5 to be AINSWORTH
 *         rs.updateRow(); // updates the row in the data source
 *  
 *  to insert column values into the insert row. An updatable ResultSet object has a special
 *   row associated with it that serves as a staging area for building a row to be inserted. 
 *   The following code fragment moves the cursor to the insert row, builds a three-column 
 *   row, and inserts it into rs and into the data source table using the method insertRow.
 *         rs.moveToInsertRow(); // moves cursor to the insert row
 *          rs.updateString(1, "AINSWORTH"); // updates the 
 *             // first column of the insert row to be AINSWORTH
 *          rs.updateInt(2,35); // updates the second column to be 35
 *          rs.updateBoolean(3, true); // updates the third column to true
 *          rs.insertRow();
 *          rs.moveToCurrentRow();
 */
public class ResultSet implements java.sql.ResultSet {

	private com.zykie.jdbc.Connection conn = null;
	private com.zykie.jdbc.Statement stmt = null;
	private QueryResponse resp = null;
	private ResultSetMetaData mData = null;
	private List<List<Object>> records = null;
	private int recordCursor = 0; // the first row is number 1
	private static final Logger log = ZykieLogger
			.getLogger("com.zykie.jdbc.ResultSet");
	private boolean isClosed = false;
	private boolean wasNullFlag = false;

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		throw SQLError.notImplemented();
	}

	/*
	 * Do nothing for now
	 */
	public ResultSet(Connection conn, Statement stmt) throws SQLException {
		this.stmt = (com.zykie.jdbc.Statement) stmt;
		this.conn = (com.zykie.jdbc.Connection) conn;
	}

	/*
	 * Releases this ResultSet object's database and JDBC resources immediately
	 * instead of waiting for this to happen when it is automatically closed.
	 * 
	 * Note: A ResultSet object is automatically closed by the Statement object
	 * that generated it when that Statement object is closed, re-executed, or
	 * is used to retrieve the next result from a sequence of multiple results.
	 * A ResultSet object is also automatically closed when it is garbage
	 * collected.
	 * 
	 * (non-Javadoc)
	 * 
	 * @see java.sql.ResultSet#close()
	 */
	@Override
	public void close() throws SQLException {
		this.isClosed = true;
	}

	/*
	 * Reports whether the last column read had a value of SQL NULL. Note that
	 * you must first call one of the getter methods on a column to try to read
	 * its value and then call the method wasNull to see if the value read was
	 * SQL NULL.
	 * 
	 * Returns: true if the last column value read was SQL NULL and false
	 * otherwise (non-Javadoc)
	 * 
	 * @see java.sql.ResultSet#wasNull()
	 */
	@Override
	public boolean wasNull() throws SQLException {
		return this.wasNullFlag;
	}

	@Override
	public String getString(int columnIndex) throws SQLException {
		Object obj = getObject(columnIndex);
		
		if (obj == null)
			return null;
		else
			return obj.toString();
	}

	@Override
	public boolean getBoolean(int columnIndex) throws SQLException {
		Object obj = getObject(columnIndex);
		
		if (obj == null)
			return false;
		else
			return Boolean.valueOf(obj.toString());
	}

	@Override
	public byte getByte(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public short getShort(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	/*
	 * Retrieves the value of the designated column in the current row of this
	 * ResultSet object as an int in the Java programming language.
	 * 
	 * Current row is positioned by recordCursor
	 * 
	 * (non-Javadoc)
	 * 
	 * @see java.sql.ResultSet#getInt(int)
	 */
	@Override
	public int getInt(int columnIndex) throws SQLException {
		Object obj = getObject(columnIndex);
		
		if (obj == null)
			return 0;
		else
			return Integer.parseInt(obj.toString());
	}

	@Override
	public long getLong(int columnIndex) throws SQLException {
		return getInt(columnIndex);
	}

	@Override
	public float getFloat(int columnIndex) throws SQLException {
		Object obj = getObject(columnIndex);
		
		if (obj == null)
			return 0;
		else
			return Float.valueOf(obj.toString());
	}

	@Override
	public double getDouble(int columnIndex) throws SQLException {
		Object obj = getObject(columnIndex);
		
		if (obj == null)
			return 0;
		else
			return Double.valueOf(obj.toString());
	}

	@Override
	public BigDecimal getBigDecimal(int columnIndex, int scale)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public byte[] getBytes(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Date getDate(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Time getTime(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Timestamp getTimestamp(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public InputStream getAsciiStream(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public InputStream getUnicodeStream(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public InputStream getBinaryStream(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public String getString(String columnLabel) throws SQLException {
		int i = this.findColumn(columnLabel);
		
		return getString(i);
	}

	@Override
	public boolean getBoolean(String columnLabel) throws SQLException {
		int i = this.findColumn(columnLabel);
		
		return getBoolean(i);
	}

	@Override
	public byte getByte(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public short getShort(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public int getInt(String columnLabel) throws SQLException {
		int i = this.findColumn(columnLabel);
		
		return getInt(i);
	}

	@Override
	public long getLong(String columnLabel) throws SQLException {
		return getInt(columnLabel);
	}

	@Override
	public float getFloat(String columnLabel) throws SQLException {
		int i = this.findColumn(columnLabel);
		
		return getFloat(i);
	}

	@Override
	public double getDouble(String columnLabel) throws SQLException {
		int i = this.findColumn(columnLabel);
		
		return getDouble(i);
	}

	@Override
	public BigDecimal getBigDecimal(String columnLabel, int scale)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public byte[] getBytes(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Date getDate(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Time getTime(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Timestamp getTimestamp(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public InputStream getAsciiStream(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public InputStream getUnicodeStream(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public InputStream getBinaryStream(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void clearWarnings() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public String getCursorName() throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		return this.mData;
	}

	/*
	 * Notice: the first column Index is 1, not 0
	 * 
	 * (non-Javadoc)
	 * @see java.sql.ResultSet#getObject(int)
	 */	
	@Override
	public Object getObject(int columnIndex) throws SQLException {	
		List<Object> record;
		
		/*
		if (!isCursorValid())
			return false;
		*/			
		record = records.get(recordCursor - 1);
		if(columnIndex > record.size() || columnIndex <= 0)
		{
			return null;
		}
		if (record.get(columnIndex - 1) == null) {
			this.wasNullFlag = true;
			return null;
		} 
			
		this.wasNullFlag = false;
		return record.get(columnIndex - 1);
	}

	@Override
	public Object getObject(String columnLabel) throws SQLException {
		int i = this.findColumn(columnLabel);
		
		return getObject(i);
	}

	/*
	 * 
	 * Maps the given ResultSet column label to its ResultSet column index. 
	 * 
	 * The first column is 1, etc
	 * 
	 * (non-Javadoc)
	 * @see java.sql.ResultSet#findColumn(java.lang.String)
	 */
	@Override
	public int findColumn(String columnLabel) throws SQLException {
		int i;
		
		if (mData == null)
			i = -1;
		else 
			i = ((com.zykie.jdbc.ResultSetMetaData)mData).findColumn(columnLabel);
		
		if (i < 0) {
			throw SQLError.createSQLException(
					Messages.getString("ResultSet.Column____112") + columnLabel
							+ Messages.getString("ResultSet.___not_found._113"), //$NON-NLS-1$ //$NON-NLS-2$
					SQLError.SQL_STATE_COLUMN_NOT_FOUND, getExceptionInterceptor());
		}
		
		return i;
	}

	@Override
	public Reader getCharacterStream(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Reader getCharacterStream(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public boolean isBeforeFirst() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		return (recordCursor < 1);
	}

	@Override
	public boolean isAfterLast() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		return (recordCursor > records.size());
	}

	@Override
	public boolean isFirst() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		return (recordCursor == 1);
	}

	@Override
	public boolean isLast() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		return (recordCursor == records.size());
	}

	@Override
	public void beforeFirst() throws SQLException {
		recordCursor = 0;
	}

	@Override
	public void afterLast() throws SQLException {
		recordCursor = records.size() + 1;
	}

	@Override
	public boolean first() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		recordCursor = 1;
		return true;
	}

	@Override
	public boolean last() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		recordCursor = records.size();
		return true;
	}

	/*
	 * Retrieves the current row number. The first row is number 1, the second
	 * number 2, and so on.
	 * 
	 * 0 if no current row
	 * 
	 * (non-Javadoc)
	 * 
	 * @see java.sql.ResultSet#getRow()
	 */
	@Override
	public int getRow() throws SQLException {
		return recordCursor;
	}

	@Override
	public boolean absolute(int row) throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		recordCursor = row;
		if ((recordCursor < 1) && (recordCursor > records.size()))
			return false;

		log.info("Current record cursor: " + recordCursor);
		return true;
	}

	/*
	 * Moves the cursor a relative number of rows, either positive or negative.
	 * Attempting to move beyond the first/last row in the result set positions
	 * the cursor before/after the the first/last row. Calling relative(0) is
	 * valid, but does not change the cursor position.
	 * 
	 * Note: Calling the method relative(1) is identical to calling the method
	 * next() and calling the method relative(-1) is identical to calling the
	 * method previous().
	 * 
	 * (non-Javadoc)
	 * 
	 * @see java.sql.ResultSet#relative(int)
	 */
	@Override
	public boolean relative(int rows) throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		recordCursor += rows;
		if ((recordCursor < 1) && (recordCursor > records.size()))
			return false;

		log.info("Current record cursor: " + recordCursor);
		return true;
	}

	@Override
	public boolean previous() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		recordCursor--;
		if (recordCursor < 1)
			return false;

		log.info("Current record cursor: " + recordCursor);
		return true;
	}

	/*
	 * Moves the cursor down one row from its current position. A ResultSet
	 * cursor is initially positioned before the first row; the first call to
	 * the method next makes the first row the current row; the second call
	 * makes the second row the current row, and so on.
	 * 
	 * If an input stream is open for the current row, a call to the method next
	 * will implicitly close it. A ResultSet object's warning chain is cleared
	 * when a new row is read.
	 * 
	 * Returns: true if the new current row is valid; false if there are no more
	 * rows
	 * 
	 * (non-Javadoc)
	 * 
	 * @see java.sql.ResultSet#next()
	 */
	@Override
	public boolean next() throws SQLException {
		if ((records == null) || records.isEmpty())
			return false;

		recordCursor++;
		if (recordCursor > records.size())
			return false;

		log.info("Current record cursor: " + recordCursor);
		return true;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public int getFetchDirection() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public int getFetchSize() throws SQLException {
		throw SQLError.notImplemented();
		

	}

	@Override
	public int getType() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public int getConcurrency() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public boolean rowUpdated() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public boolean rowInserted() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public boolean rowDeleted() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNull(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateByte(int columnIndex, byte x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateShort(int columnIndex, short x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateInt(int columnIndex, int x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateLong(int columnIndex, long x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateFloat(int columnIndex, float x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateDouble(int columnIndex, double x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBigDecimal(int columnIndex, BigDecimal x)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateString(int columnIndex, String x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateDate(int columnIndex, Date x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateTime(int columnIndex, Time x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateTimestamp(int columnIndex, Timestamp x)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, int length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateObject(int columnIndex, Object x, int scaleOrLength)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateObject(int columnIndex, Object x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNull(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBoolean(String columnLabel, boolean x)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateByte(String columnLabel, byte x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateShort(String columnLabel, short x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateInt(String columnLabel, int x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateLong(String columnLabel, long x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateFloat(String columnLabel, float x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateDouble(String columnLabel, double x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBigDecimal(String columnLabel, BigDecimal x)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateString(String columnLabel, String x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBytes(String columnLabel, byte[] x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateDate(String columnLabel, Date x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateTime(String columnLabel, Time x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateTimestamp(String columnLabel, Timestamp x)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader,
			int length) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateObject(String columnLabel, Object x, int scaleOrLength)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateObject(String columnLabel, Object x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void insertRow() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateRow() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void deleteRow() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void refreshRow() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void cancelRowUpdates() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void moveToInsertRow() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void moveToCurrentRow() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Statement getStatement() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Object getObject(int columnIndex, Map<String, Class<?>> map)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Ref getRef(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Blob getBlob(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Clob getClob(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Array getArray(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Object getObject(String columnLabel, Map<String, Class<?>> map)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Ref getRef(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Blob getBlob(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Clob getClob(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Array getArray(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Date getDate(int columnIndex, Calendar cal) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Date getDate(String columnLabel, Calendar cal) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Time getTime(int columnIndex, Calendar cal) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Time getTime(String columnLabel, Calendar cal) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Timestamp getTimestamp(int columnIndex, Calendar cal)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Timestamp getTimestamp(String columnLabel, Calendar cal)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public URL getURL(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public URL getURL(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateRef(int columnIndex, Ref x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateRef(String columnLabel, Ref x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBlob(int columnIndex, Blob x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBlob(String columnLabel, Blob x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateClob(int columnIndex, Clob x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateClob(String columnLabel, Clob x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateArray(int columnIndex, Array x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateArray(String columnLabel, Array x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public RowId getRowId(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public RowId getRowId(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateRowId(int columnIndex, RowId x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateRowId(String columnLabel, RowId x) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public int getHoldability() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public boolean isClosed() throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNString(int columnIndex, String nString)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNString(String columnLabel, String nString)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNClob(String columnLabel, NClob nClob)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public NClob getNClob(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public NClob getNClob(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public SQLXML getSQLXML(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public SQLXML getSQLXML(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateSQLXML(int columnIndex, SQLXML xmlObject)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateSQLXML(String columnLabel, SQLXML xmlObject)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public String getNString(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public String getNString(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Reader getNCharacterStream(int columnIndex) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public Reader getNCharacterStream(String columnLabel) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, long length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x,
			long length) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream, long length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream,
			long length) throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		throw SQLError.notImplemented();

	}

	@Override
	public void updateClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateNClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateNClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateClob(int columnIndex, Reader reader) throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateClob(String columnLabel, Reader reader)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		throw SQLError.notImplemented();
	}

	@Override
	public void updateNClob(String columnLabel, Reader reader)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
		throw SQLError.notImplemented();
	}

	public <T> T getObject(String columnLabel, Class<T> type)
			throws SQLException {
		throw SQLError.notImplemented();
	}

	/*******************************************************************
	 ***** JimoDB method
	 *******************************************************************/
	public void setQueryResponse(QueryResponse resp) {
		this.resp = resp;
		this.records = resp.getRecords();		
		this.mData = new com.zykie.jdbc.ResultSetMetaData(resp.getFields(), 
				false, false, getExceptionInterceptor());
	}

	public QueryResponse getQueryResponse() {
		return this.resp;
	}

	public boolean addRecord(List<Object> record) {
		if (this.records == null)
			this.records = new ArrayList<List<Object>>();

		records.add(record);
		return true;
	}
	
	public boolean hasRecord() {
		if (this.records == null)
			return false;
		if(records.size() == 0)
			return false;
		return true;
	}

	public void setMetaData(ResultSetMetaData mData) {
		this.mData = mData;
	}

	public boolean addRecord(Object row[]) throws SQLException {
		List<Object> record = new ArrayList<Object>();
		
		if (row == null)
			return false;

		// add record
		for (int i = 0; i < row.length; i++) {
			record.add(row[i]);
		}

		addRecord(record);
		return true;
	}

	public boolean isCursorValid() {
		if (records == null || records.isEmpty())
			return false;

		return (recordCursor >= 1 && recordCursor <= records.size());
	}
	
	public ExceptionInterceptor getExceptionInterceptor() {
		return this.conn.getExceptionInterceptor();
	}
	
	public String getColumnName(int columnIndex) throws SQLException {
		if (mData == null)
			return null;
		
		return mData.getColumnName(columnIndex);
	}
}


