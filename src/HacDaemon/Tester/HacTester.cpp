//////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility. 
//
// Modification History:
// 4/21/2007 Created by TorturerGen Facility
//////////////////////////////////////////////////////////////////////////
#include "HacDaemon/Tester/HacTester.h"

#include "Debug/Debug.h"
#include "HacDaemon/Tester/HacCliTester.h"
#include "Porting/Sleep.h"
#include "Random/RandomInteger.h"
#include "StreamSimu/StreamSimuMgr.h"
#include "Tester/Test.h"
#include "Tester/TestMgr.h"
#include "Thread/Mutex.h"
#include "Util/GenTable.h"
#include "Util/OmnNew.h"
#include "Util/Random.h"


static OmnMutex sgLock;

//
// Application Type selector definition
//
static OmnString sgAppTypeSelectorDef =
"<Elements>"
	"<Element>5,  25</Element>"  // FTP 
	"<Element>6,  25</Element>"  // Telnet 
	"<Element>7,  25</Element>"  // SSH
	"<Element>8,  0</Element>"   // Windows Terminal
"</Elements>";


AosHacTester::AosHacTester()
:
mBasicTestRepeat(10000),
mCliTester(OmnNew AosHacCliTester()),
mMaxConns(eDefaultMaxConns),
mMaxTrafficDuration(eDefaultMaxTrafficDuration),
mStartPort(eDefaultStartPort),
mEndPort(eDefaultEndPort),
mNumConns(0),
mCorrectUserPct(eDefaultCorrectUserPct),
mCorrectPwdPct(eDefaultCorrectPwdPct),
mCorrectSendIPPct(eDefaultCorrectSendIPPct),
mCorrectRecvIPPct(eDefaultCorrectRecvIPPct)
{
    mBasicTestRepeat = 10000;

    mAppTypeSelector = OmnNew AosRandomInteger("AppTypeSelector",
	                                            sgAppTypeSelectorDef, 
											    0);

	for (u16 i=mStartPort; i<mEndPort; i++)
	{
		mPorts.append(i);
	}
}


AosHacTester::~AosHacTester()
{
}


bool
AosHacTester::start()
{
    basicTest(mBasicTestRepeat, mTable);
    return true;
}


bool
AosHacTester::basicTest(const u32 repeat, const AosGenTablePtr &table)
{
	u32 tries = 0;
	while (tries++ < repeat)
	{
		if (!mCliTester->config() || !runTraffic()) return false;
	}

	return true;
}


bool
AosHacTester::runTraffic()
{
	// 
	// Randomly determine how many concurrent connections to run
	//
	u32 numConns = nextNumConcurrentConns();
	
	// 
	// Randomly determine the duration to run this time
	//
	u32 duration = getNextDuration();
	u32 crtTime = OmnTime::getCrtSec();
	u32 stopTime = crtTime + duration;
	while (OmnTime::getCrtSec() < stopTime)
	{
		if (numConns < mNumConns)
		{
			// 
			// We need to wait until the current concurrent connections
			// drop under 'numConns'
			//
			OmnSleep(1);
			continue;
		}

		// 
		// The current concurrent conns is not as many as we wanted
		// Will randomly determine how many to start this time.
		//
		int connToStart = OmnRandom::nextInt(1, numConns-mNumConns);

		for (int i=0; i<connToStart; i++)
		{
			if (!addConn()) return false;
		}

		mNumConns += connToStart;

		OmnSleep(1);
	}

	return true;
}


u32 
AosHacTester::nextNumConcurrentConns()
{
	// 
	// This function determines the next number of 
	// concurrent connections we want to run. We will
	// simply select one from the range [1, mMaxConns].
	//
	return OmnRandom::nextInt(1, mMaxConns);
}


u32
AosHacTester::getNextDuration()
{
	// 
	// This function returns the next duration to run 
	// the traffic. This is determined using the
	// range [1, mMaxTrafficDuration].
	//
	return OmnRandom::nextInt(1, mMaxTrafficDuration);
}


bool
AosHacTester::addConn()
{
	//
	// This function adds a new connection. The following 
	// torturing variables are considered by this function:
	// 1. The application to run: telnet, ftp, ssh
	// 2. The user (correct user or incorrect user)
	// 3. Password (correct password or incorrect password)
	// 4. Application allowed or not allowed
	//
	OmnString user, passwd;
	OmnIpAddr sendIP, recvIP; 
	int sendPort, recvPort;
	AosStreamType::E app;
	bool good;
	if (!getAppInfo(app, user, passwd, sendIP, sendPort, recvIP, recvPort, good))
	{
		return false;
	}

	bool ret = AosStreamSimuMgr::getSelf()->addStream(
		sendIP, sendPort, recvIP, recvPort, app);

	if (!ret)
	{
		OmnAlarm << "Failed to add stream" << enderr;
		return false;
	}

	return true;
}


bool
AosHacTester::getAppInfo(AosStreamType::E &app, 
						 OmnString &user,
						 OmnString &pwd,
						 OmnIpAddr &sendIP, 
						 int       &sendPort,
						 OmnIpAddr &recvIP, 
						 int 	   &recvPort, 
						 bool	   &pass)
{
	// 
	// This function uses mClitorturer to generate all the information
	// for a connection:
	// 0. App
	// 1. User
	// 2. Password
	// 3. sendIP
	// 4. recvIP
	// 5. sendPort
	// 6. recvPort
	// 7. pass
	//
	// If the connection is a valid connection, the connection should
	// pass (.e., 'pass' is set to trre. Otherwise, it sets to false. 
	//
	app = (AosStreamType::E)mAppTypeSelector->nextInt();	

	pass = true;
	bool userGood = PERCENTAGE(mCorrectUserPct);
	if (!mCliTester->getUser(userGood, app, user)) return false;
	pass = userGood;

	bool pwdGood = PERCENTAGE(mCorrectPwdPct);
	if (!mCliTester->getPasswd(pwdGood, user, pwd)) return false;
	pass = pass && pwdGood;

	bool sendIPGood = PERCENTAGE(mCorrectSendIPPct);
	if (!mCliTester->getSendIP(sendIPGood, user, app, sendIP)) return false;
	pass = pass && sendIPGood;

	sendPort = getSendPort();
	if (sendPort < 0) return false;

	bool rcvGood = PERCENTAGE(mCorrectRecvIPPct);
	if (!mCliTester->getRecvIPPort(rcvGood, app, user, recvIP, recvPort)) return false;
	pass = pass && rcvGood;
	
	return true;
}


int
AosHacTester::getSendPort()
{
	sgLock.lock();
	if (mPorts.entries())
	{
		sgLock.unlock();
		OmnAlarm << "Run out of ports" << enderr;
		return -1;
	}

	int port = mPorts.popFront();
	sgLock.unlock();
	return port;
}

