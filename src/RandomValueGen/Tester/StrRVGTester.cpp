//////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility. 
//
// Modification History:
// 05/06/2007 Created by TorturerGen Facility
//////////////////////////////////////////////////////////////////////////
#include "RandomValueGen/Tester/StrRVGTester.h"

#include "RandomValueGen/Ptrs.h"
#include "RandomValueGen/RVGStr.h"
#include "RandomValueGen/Util.h"
#include "RandomValueGen/Tester/Util.h"
#include "RandomValueGen/ReturnCode.h"
#include "Debug/Debug.h"
#include "Tester/Test.h"
#include "Tester/TestMgr.h"
#include "Util/OmnNew.h"
#include "Util/GenTable.h"
#include "Util/StrParser.h"
#include "Util/GenRecord.h"
#include "XmlParser/XmlItem.h"


AosStrRVGTester::AosStrRVGTester()
{
    mName = "AosStrRVGTester";
}


AosStrRVGTester::~AosStrRVGTester()
{
}


bool
AosStrRVGTester::start()
{
	u32 tries = 10;
//	createData();
//	stressTest(1000000 * 100);
	testTimeStr(tries);
    return true;
}


const OmnString sgTableWithKeyDef = 
"<TableDef>"
	"<MaxEntries>100</MaxEntries>"
	"<KeyFields>app_name</KeyFields>"
	"<Fields>"
		"<Field>"
			"<Type>string</Type>"
			"<Name>app_name</Name>"
		"</Field>"
	"</Fields>"
"</TableDef>";

const OmnString sgTableNoKeyDef = 
"<TableDef>"
	"<MaxEntries>100</MaxEntries>"
	"<Fields>"
		"<Field>"
			"<Type>string</Type>"
			"<Name>app_name</Name>"
		"</Field>"
	"</Fields>"
"</TableDef>";

bool
AosStrRVGTester::createData()
{
	// 
	// Create Parms 
	//
	/*
	OmnXmlItemPtr item = OmnNew OmnXmlItem(sgTableWithKeyDef);
	mTableWithKey = OmnNew AosGenTable(item);

	OmnDynArray<AosGenTablePtr> depTables;
	OmnDynArray<OmnString> fieldnames;
	item = OmnNew OmnXmlItem(sgTableNoKeyDef);
	mTableNoKey = OmnNew AosGenTable(item);

	mParmNew = OmnNew AosRVGStr("StrTester", 3, 15, "app_name", 
					eAosRVGKeyType_SingleKeyNew, false, mTableWithKey, 
					depTables, fieldnames, "***BAD***", 
					eAosStrType_VarName);
	mParmExist = OmnNew AosRVGStr("StrTester", 3, 15, "app_name", 
					eAosRVGKeyType_SingleKeyExist, false, mTableWithKey, 
					depTables, fieldnames, "***BAD***", 
					eAosStrType_VarName);
	mParmNotKey = OmnNew AosRVGStr("StrTester", 3, 15, "app_name", 
					eAosRVGKeyType_NoKey, false, mTableNoKey, 
					depTables, fieldnames, "***BAD***", 
					eAosStrType_VarName);
	*/

	return true;
}

bool
AosStrRVGTester::testTimeStr(u32 tries)
{
    //
	//  <Parm>
	//      <type>
	//      <Name>
	//      <MinLen>
	//      <MaxLen>
	//      <FieldName>
	//      <KeyType>
	//      <BadValue>
	//      <CorrectOnly>
	//      <StrType>
	//      <BadStrGen>
	//      <TableName>
	//      <DependedTables>
	//      ...
	//  </Parm>
	//
	OmnString lsParmDef = 
		"<Parm>"
			"<type>string</type>"
			"<Name>AppName</Name>"
			"<FieldName>app_name</FieldName>"
			"<MinLen>1</MinLen>"
			"<MaxLen>16</MaxLen>"
			"<KeyType>New</KeyType>"
			"<BadValue>***BBB***</BadValue>"
			"<CorrectOnly>false</CorrectOnly>"
			"<StrType>HH:MM:SS</StrType>"
			"<BadStrGen>"
				"<StrType>InvalidHH:MM:SS</StrType>"
				"<MinLen>5</MinLen>"
				"<MaxLen>20</MaxLen>"
			"</BadStrGen>"
			"<TableName>app_table</TableName>"
		"</Parm>";
	
	return runParm(lsParmDef, sgTableWithKeyDef, tries);
}


bool
AosStrRVGTester::runParm(const OmnString &parmDef, 
						  const OmnString &dbDef, 
						  const u32 tries)
{
	/*
	OmnXmlItemPtr item = OmnNew OmnXmlItem(dbDef);
	AosGenTablePtr table = OmnNew AosGenTable(item);
	OmnVList<AosGenTablePtr> tables;
	tables.append(table);

	OmnXmlItemPtr parmItem = OmnNew OmnXmlItem(parmDef);
	AosRVGPtr parm = AosRVG::createParm(parmItem, tables);
	if (!parm)
	{
		OmnAlarm << "Failed to create the parm: " << parmDef
			<< enderr;
		return false;
	}


	OmnString value;
	AosGenRecordPtr record = table->createRecord();
	bool isGood;
	AosRVGReturnCode rcode;
	OmnString errmsg;
	for (u32 i=0; i<tries; i++)
	{
		OmnTCTrue(parm->nextStr(value, table, record, isGood, false, 
			rcode, errmsg)) << endtc;
		if (isGood)
		{
			cout << "Parm(y): " << value << endl;
		}
		else
		{
			cout << "Parm(n): " << value << ". Error: " << errmsg << endl;
		}
		check(__FILE__, __LINE__, isGood, value, errmsg);
	}
	*/

	return true;
}


bool
AosStrRVGTester::check(const OmnString &file, 
						const int line, 
						const bool flag,
						const OmnString &value, 
						const OmnString &errmsg)
{
	OmnStrParser parser(value);
	OmnString seg1 = parser.nextDigits("");
	char c1 = parser.nextChar();
	OmnString seg2 = parser.nextDigits("");
	char c2 = parser.nextChar();
	OmnString seg3 = parser.nextDigits("");

	OmnString recons = seg1;
	recons << c1 << seg2 << c2 << seg3;
	bool actual = seg1 != "" && seg2 != "" && seg3 != "" &&
			  seg1.isDigitStr() &&
			  seg2.isDigitStr() &&
			  seg3.isDigitStr() &&
			  recons == value &&
			  c1 == ':' && c2 == ':';
	OmnTC(OmnExpected<bool>(flag), OmnActual<bool>(actual)) 
		<< value << ". Error: " << errmsg << endtc;

	return true;
}
