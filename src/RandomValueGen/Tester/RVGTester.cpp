//////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility. 
//
// Modification History:
// 05/06/2007 Created by TorturerGen Facility
//////////////////////////////////////////////////////////////////////////
#include "RandomValueGen/Tester/RVGTester.h"

#include "RandomValueGen/Ptrs.h"
#include "RandomValueGen/RVGNetmask.h"
#include "RandomValueGen/Util.h"
#include "RandomValueGen/Tester/Util.h"
#include "Debug/Debug.h"
#include "Tester/Test.h"
#include "Tester/TestMgr.h"
#include "Util/OmnNew.h"
#include "Util/GenTable.h"
#include "Util/GenRecord.h"
#include "XmlParser/XmlItem.h"


AosRVGTester::AosRVGTester()
{
	for (u32 i=0; i<ArraySize; i++)
	{
		mStatus[i] = 0;
	}
}


AosRVGTester::~AosRVGTester()
{
}


bool
AosRVGTester::stressTest(const u32 tries)
{
	OmnString value;
	u32 count = 0;
	for (u32 i=0; i<tries; i++)
	{
		if (count == 10000)
		{
			cout << "Count: " << i << ". Table size: " << mTableWithKey->entries() 
				 << ": " << mTableNoKey->entries() << endl;
			count = 0;
		}
		count++;

		int select = aos_next_int(1, 100);
		if (select < 33)
		{
//			shrinkKeyTable();
			runNewKey();
		}
		else if (select < 66)
		{
//			shrinkKeyTable();
			runExistKey();
		}
		else 
		{
//			shrinkNoKeyTable();
			runNoKey();
		}
	}

	printStatus(tries);
	return true;
}
	

bool
AosRVGTester::testNewKey()
{
	mTries = 100000000;
	u32 count = 0;
	for (u32 i=0; i<mTries; i++)
	{
		if (count == 10000)
		{
			cout << "Count: " << i << ". Table size: " << mTableWithKey->entries() << endl;
			count = 0;
		}
		count++;

		OmnTCBool(true, runNewKey()) << endtc;
	}

	OmnTCBool(true, mStatus[eAosRVGRc_ProgramError] == 0) 
			<< "Program Error found: " << mStatus[eAosRVGRc_ProgramError] << endtc;
	printStatus(mTries);
	return true;
}


bool
AosRVGTester::printStatus(const u32 total)
{
	cout << "Table With Key: \n" << mTableWithKey->toString() << endl;
	// cout << "Table Without Key: \n" << mTableNoKey->toString() << endl;

	cout << "Total: " << total << endl;
	for (int i=0; i<eAosRVGRc_LastEntry; i++)
	{
		OmnString name = AosRVGRc_toStr((AosRVGReturnCode)i);
		OmnString dd;
		dd << mStatus[i] << "            ";
		dd.setLength(15);
		name << ":             ";

		if (mStatus[i])
		{
			name.setLength(18);
		}
		else
		{
			name.setLength(20);
		}
		OmnString pct;
		pct << (float)(mStatus[i] * 100.0 / total);
		cout << name << dd << pct << endl;
	}

	cout << endl;

	return true;
}


bool
AosRVGTester::runNewKey()
{
	bool isGood;
	OmnString value;
	AosRVGReturnCode rcode;
	AosGenRecordPtr record = mTableWithKey->createRecord();
	OmnString errmsg;
	if (!mParmNew->nextStr(value, mTableWithKey, record, isGood, false, false, rcode, errmsg))
	{
		OmnAlarm << "Failed to generate parm" << enderr;
		return false;
	}
	
	if (isGood)
	{
		rcode = eAosRVGRc_Success;
		OmnTCBool(true, AosCliTorturerUtil_addToTable(mTableWithKey, value, mParmNew)) << endtc;
	}

	return recordReturnCode(value, mParmNew, errmsg, rcode);
}


bool
AosRVGTester::runExistKey()
{
	AosRVGReturnCode rcode;
	OmnString value; 
	AosGenRecordPtr record = mTableWithKey->createRecord();
	OmnString errmsg;
	bool isGood;
	if (!mParmExist->nextStr(value, mTableWithKey, record, isGood, false, false, rcode, errmsg))
	{
		OmnAlarm << "Failed to generate parm" << enderr;
		return false;
	}
	
	if (isGood && rcode != eAosRVGRc_ExistInTable 
			   && rcode != eAosRVGRc_SelectFromRecord 
			   && rcode != eAosRVGRc_SelectFromTable)
	{
		rcode = eAosRVGRc_Success;
		OmnTCBool(true, AosCliTorturerUtil_addToTable(mTableWithKey, value, mParmExist)) << endtc;
	}

	return recordReturnCode(value, mParmExist, errmsg, rcode);
}


bool
AosRVGTester::runNoKey()
{
	AosRVGReturnCode rcode;
	OmnString value; 
	AosGenRecordPtr record = mTableWithKey->createRecord();
	OmnString errmsg;
	bool isGood;
	if (!mParmNotKey->nextStr(value, mTableWithKey, record, isGood, false, false, rcode, errmsg))
	{
		OmnAlarm << "Failed to generate parm" << enderr;
		return false;
	}
	
	if (isGood)
	{
		rcode = eAosRVGRc_Success;
		OmnTCBool(true, AosCliTorturerUtil_addToTable(mTableNoKey, value, mParmExist)) << endtc;
	}

	return recordReturnCode(value, mParmNotKey, errmsg, rcode);
}


bool
AosRVGTester::recordReturnCode(const OmnString &value, 
								const AosRVGPtr &parm,
								const OmnString &errmsg, 
								const AosRVGReturnCode rcode)
{
	if (rcode >= 0 && rcode < eAosRVGRc_LastEntry)
	{
		mStatus[rcode]++;
		return true;
	}


	OmnTCBool(false, true) << "Unrecognized rcode: " << rcode << endtc;
	return true;
}


bool
AosRVGTester::shrinkKeyTable()
{
	if (mTableWithKey->entries() >= 32)
	{
		// 
		// We will randomly remove some records
		//
		int numRecordsToRemove = aos_next_int(1, 10);
		for (int i=0; i<numRecordsToRemove; i++)
		{
			mTableWithKey->removeRecordRandomly();
		}
	}

	return true;
}

	
bool
AosRVGTester::shrinkNoKeyTable()
{
	if (mTableNoKey->entries() < mTableNoKey->getMax()*0.8) return true;
	if (mTableNoKey->entries() > 0)
	{
		// 
		// We will randomly remove some records
		//
		int numRecordsToRemove = aos_next_int(1, 10);
		for (int i=0; i<numRecordsToRemove; i++)
		{
			mTableNoKey->removeRecordRandomly();
		}
	}

	return true;
}


