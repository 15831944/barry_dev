//////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility. 
//
// Modification History:
// 05/10/2007 Created by TorturerGen Facility
//////////////////////////////////////////////////////////////////////////
#include "RandomValueGen/Tester/StrEnumRVGTester.h"

#include "RandomValueGen/Ptrs.h"
#include "RandomValueGen/RVGStrEnum.h"
#include "RandomValueGen/Util.h"
#include "RandomValueGen/Tester/Util.h"
#include "Debug/Debug.h"
#include "Tester/Test.h"
#include "Tester/TestMgr.h"
#include "Util/OmnNew.h"
#include "Util/GenTable.h"
#include "Util/StrParser.h"
#include "Util/GenRecord.h"
#include "XmlParser/XmlItem.h"


AosStrEnumRVGTester::AosStrEnumRVGTester()
{
    mName = "AosStrEnumRVGTester";
}


AosStrEnumRVGTester::~AosStrEnumRVGTester()
{
}


bool
AosStrEnumRVGTester::start()
{
	u32 tries = 10000;
	testStrList(tries);
    return true;
}


const OmnString sgTableWithKeyDef = 
"<TableDef>"
	"<MaxEntries>100</MaxEntries>"
	"<KeyFields>app_name</KeyFields>"
	"<Fields>"
		"<Field>"
			"<Type>string</Type>"
			"<Name>app_name</Name>"
		"</Field>"
	"</Fields>"
"</TableDef>";

const OmnString sgTableNoKeyDef = 
"<TableDef>"
	"<MaxEntries>100</MaxEntries>"
	"<Fields>"
		"<Field>"
			"<Type>string</Type>"
			"<Name>app_name</Name>"
		"</Field>"
	"</Fields>"
"</TableDef>";


bool
AosStrEnumRVGTester::testStrList(u32 tries)
{
    //
	//  <Parm>
	//      <type>
	//      <Name>
	//      <MinLen>
	//      <MaxLen>
	//      <FieldName>
	//      <KeyType>
	//      <Values>v1, v2, ...</Values>
	//      <BadValue>
	//      <CorrectOnly>
	//      <StrType>
	//      <BadStrGen>
	//      <TableName>
	//      <DependedTables>
	//      ...
	//  </Parm>
	//
	OmnString lsParmDef = 
		"<Parm>"
			"<type>stringlist</type>"
			"<Name>AppName</Name>"
			"<FieldName>app_name</FieldName>"
			"<MinLen>1</MinLen>"
			"<Selector>"
				"<Values>[mon, 1], [tue, 1], [wed, 1], [thr, 1], [fri, 1], [sat, 1]</Values>"
				"<BadValue>******</BadValue>"
				"<SeparatorDef>"
					"<Separator>|</Separator>"
					"<MinSeg>1</MinSeg>"
					"<MaxSeg>7</MaxSeg>"
					"<Unique>false</Unique>"
					"<Ordered>false</Ordered>"
				"</SeparatorDef>"
				"<IncorrectGen>"
					"<StrType>DigitStr</StrType>"
					"<MinLen>1</MinLen>"
					"<MaxLen>16</MaxLen>"
				"</IncorrectGen>"
			"</Selector>"
			"<MaxLen>27</MaxLen>"
			"<KeyType>New</KeyType>"
			"<BadValue>***BBB***</BadValue>"
			"<CorrectOnly>false</CorrectOnly>"
			"<StrType>HH:MM:SS</StrType>"
			"<BadStrGen>"
				"<StrType>DigitStr</StrType>"
				"<MinLen>5</MinLen>"
				"<MaxLen>20</MaxLen>"
			"</BadStrGen>"
			"<TableName>app_table</TableName>"
		"</Parm>";
	
	return runParm(lsParmDef, sgTableWithKeyDef, tries);
}


bool
AosStrEnumRVGTester::runParm(const OmnString &parmDef, 
						  const OmnString &dbDef, 
						  const u32 tries)
{
	OmnXmlItemPtr item = OmnNew OmnXmlItem(dbDef);
	AosGenTablePtr table = OmnNew AosGenTable(item);
	OmnVList<AosGenTablePtr> tables;
	tables.append(table);

	/*
	OmnXmlItemPtr parmItem = OmnNew OmnXmlItem(parmDef);
	AosRVGPtr parm = AosRVG::createRVG(parmItem, tables);
	if (!parm)
	{
		OmnAlarm << "Failed to create the parm: " << parmDef
			<< enderr;
		return false;
	}


	OmnString value;
	AosGenRecordPtr record = table->createRecord();
	bool isGood;
	AosRVGReturnCode rcode;
	OmnString errmsg;
	for (u32 i=0; i<tries; i++)
	{
		OmnTCTrue(parm->nextStr(value, table, record, isGood, false, 
			rcode, errmsg)) << endtc;
		if (isGood)
		{
//			cout << "Parm(y): " << value << endl;
		}
		else
		{
			cout << "Parm(n): " << value << ". Error: " << errmsg << endl;
		}
		check(__FILE__, __LINE__, isGood, value, errmsg);
	}
	*/

	return true;
}


bool
AosStrEnumRVGTester::check(const OmnString &file, 
						const int line, 
						const bool flag,
						const OmnString &values, 
						const OmnString &errmsg)
{
	OmnStrParser parser(values);
	parser.reset();
	int count = 0;
	while (count++ < 7 && parser.hasMore())
	{
		OmnString value = parser.nextWord("", '|', true);
		bool actual = (value == "mon") ||
				  	  (value == "tue") ||
				  	  (value == "wed") ||
				  	  (value == "thr") ||
				  	  (value == "fri") ||
				  	  (value == "sat") ||
				  	  (value == "sun");

		if (flag)
		{
			OmnTC(OmnExpected<bool>(flag), OmnActual<bool>(actual)) 
				<< "Value: " << value 
				<< "Flag: " << flag
				<< ". Values: " << values << ". Error: " << errmsg << endtc;
		}
	}

	if (!parser.hasMore()) return true;
	OmnTCBool(flag, false) << "Too many values " << flag 
		<< ": " << values << endtc;

	return true;
}

