//////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility. 
//
// Modification History:
// 7/18/2007 : Created by TorturerGen Facility
//////////////////////////////////////////////////////////////////////////
#include "AutoTorturing/src/QoS/qos_aos_qos_retrieve_generalrule_Tester.h"

#include "CliTorturer/CliTorturer.h"
#include "CliTorturer/ApiTorturerDef.h"
#include "Torturer/Parm.h"
#include "Torturer/ParmIncls.h"
#include "TorturerConds/CondCheckTable.h"
#include "Util/VarList.h"
#include "Util/GenTable.h"
#include "Util/GenRecord.h"
#include "AutoTorturing/src/QoS/Ptrs.h"
#include "TestUtil.h"
#include "Util/IpAddr.h"

#include "InstGen_qos_genrule.h"


AosDefineApiTorturer(AosClass_aos_qos_retrieve_generalrule, AosClass_aos_qos_retrieve_generalrulePtr, "RetrieveGenRule")

static bool
aos_table_checker_set_record(const AosGenRecordPtr &record, 
                   void *data, 
                   const int index)
{
    aos_assert_1(data, false);
    aos_assert_1(record, false);

    struct qos_genrule *theData = (struct qos_genrule *)data;
    record->set("sip", OmnIpAddr(theData[index].src_ip).toString());
    record->set("sport", theData[index].src_port);
    record->set("dip", OmnIpAddr(theData[index].dst_ip).toString());
    record->set("dport", theData[index].dst_port);
    record->set("proto", aos_test_util_proto_int2str(theData[index].protocol));
    record->set("ifname", theData[index].dev_name);

    return true;
}


bool
AosClass_aos_qos_retrieve_generalrule::runFunc(bool &correctOnly, 
					   const AosCliTorturerPtr &torturer, 
					   const OmnTestMgrPtr &testMgr, 
					   bool &cmdCorrect)
{
	// 
	// Below are the lines to generate individual arguments
	//
	mTestMgr = testMgr;
	mExecutionFailed = false;
	mExecutionErrmsg = "";
	;
mArg1 = 100;


	 
	
	
	int __ret;
    if (!(AosCliTorturer::getTestOnlyFlag() || correctOnly && !cmdCorrect))
    {
        correctOnly = true;
         __ret = aos_qos_retrieve_generalrule(mArg0, &mArg1);
    }
    else
    {
        correctOnly = false;
    }
    mFuncRet = "";
    mFuncRet << __ret;
	
	    for (int i=0; i<mArg1; i++)
		{
		    cout << "General Rule: " 
				 << OmnIpAddr(mArg0[i].src_ip).toString() << ":" << mArg0[i].src_port
				 << endl;
		}
	
	AosTortCondCheckTable tableChecker(mTable,
                aos_table_checker_set_record, mArg0, mArg1);
    bool rslt;
    OmnString errmsg;
    AosCondData data;
    bool tableCheckRet = tableChecker.check(data, rslt, errmsg);
    OmnTCTrue(tableCheckRet) << "Failed to check table. "
    << " Error message: " << errmsg << endtc;
    if (rslt) return true;

    OmnTCTrue(rslt) << "The retrieved contents do not match with the database. "
    << "Errmsg: " << errmsg << endtc;

	return true;
}


bool    
AosClass_aos_qos_retrieve_generalrule::preAddToTableProc(const AosGenTablePtr &table,
                    const AosGenRecordPtr &record,
					bool &cmdCorrect,       
					OmnString &cmdErrmsg)
{

	return true;
}

