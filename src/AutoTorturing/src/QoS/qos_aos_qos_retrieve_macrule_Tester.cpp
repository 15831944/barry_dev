//////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility. 
//
// Modification History:
// 7/18/2007 : Created by TorturerGen Facility
//////////////////////////////////////////////////////////////////////////
#include "AutoTorturing/src/QoS/qos_aos_qos_retrieve_macrule_Tester.h"

#include "CliTorturer/CliTorturer.h"
#include "CliTorturer/ApiTorturerDef.h"
#include "Torturer/Parm.h"
#include "Torturer/ParmIncls.h"
#include "TorturerConds/CondCheckTable.h"
#include "Util/VarList.h"
#include "Util/GenTable.h"
#include "Util/GenRecord.h"
#include "AutoTorturing/src/QoS/Ptrs.h"

#include "InstGen_qos_macrule.h"


AosDefineApiTorturer(AosClass_aos_qos_retrieve_macrule, AosClass_aos_qos_retrieve_macrulePtr, "RetrieveMacRule")

static bool
aos_table_checker_set_record(const AosGenRecordPtr &record, 
                   void *data, 
                   const int index)
{
    aos_assert_1(data, false);
    aos_assert_1(record, false);

    struct qos_macrule *theData = (struct qos_macrule *)data;
    record->set("mac", theData[index].mac);

    return true;
}


bool
AosClass_aos_qos_retrieve_macrule::runFunc(bool &correctOnly, 
					   const AosCliTorturerPtr &torturer, 
					   const OmnTestMgrPtr &testMgr, 
					   bool &cmdCorrect)
{
	// 
	// Below are the lines to generate individual arguments
	//
	mTestMgr = testMgr;
	mExecutionFailed = false;
	mExecutionErrmsg = "";
	;
mArg1 = 100;


	 
	
	
	int __ret;
    if (!(AosCliTorturer::getTestOnlyFlag() || correctOnly && !cmdCorrect))
    {
        correctOnly = true;
         __ret = aos_qos_retrieve_macrule(mArg0, &mArg1);
    }
    else
    {
        correctOnly = false;
    }
    mFuncRet = "";
    mFuncRet << __ret;
	
	    for (int i=0; i<mArg1; i++)
		{
		    cout << "Mac Rule: " << mArg0[i].mac << ":" << mArg0[i].priority <<
			endl;
		}
	
	AosTortCondCheckTable tableChecker(mTable,
                aos_table_checker_set_record, mArg0, mArg1);
    bool rslt;
    OmnString errmsg;
    AosCondData data;
    bool tableCheckRet = tableChecker.check(data, rslt, errmsg);
    OmnTCTrue(tableCheckRet) << "Failed to check table. "
    << " Error message: " << errmsg << endtc;
    if (rslt) return true;

    OmnTCTrue(rslt) << "The retrieved contents do not match with the database. "
    << "Errmsg: " << errmsg << endtc;

	return true;
}


bool    
AosClass_aos_qos_retrieve_macrule::preAddToTableProc(const AosGenTablePtr &table,
                    const AosGenRecordPtr &record,
					bool &cmdCorrect,       
					OmnString &cmdErrmsg)
{

	return true;
}

