/*
 * generated by genAPI.py
 * author: bill xia<xw_cn@163.com>
 */
#include "common.h"
#include "aos/aosReturnCode.h"
#include "dnsmasq.h"
#include <stdio.h>
#define MAX_BUFF_LEN 10240

#define MIN(x,y) ((x)>(y)?(y):(x))
struct dnsmasqBindEntry dnsmasqBind;
//AOS_LIST_HEAD(sgDnsmasqBindList);
struct dnsmasqHostsEntry dnsmasqHosts;
//AOS_LIST_HEAD(sgDnsmasqHostsList);
static struct dnsmasqConfigEntry dnsmasq;

/*
 * starts dnsmasq Server
 */
int aos_dnsmasq_start()
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq start ");

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * stops dnsmasq Server
 */
int aos_dnsmasq_stop()
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq stop ");

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * show current offer log
 */
int aos_dnsmasq_retrieve_log(char* result, int* resultlen)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];
	int len;

	sprintf(cmd, "dnsmasq show log ");

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	len = strlen(rslt);
	if (len > *resultlen)
	{
		strncpy(result, rslt, *resultlen);
		return eAosRc_LenTooShort;
	}
	else
	{
		strcpy(result, rslt);
		*resultlen = len;
	}
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}


/*
 * set the hostname
 */
int aos_dnsmasq_set_name(char* str1)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq set name  %s ", str1);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * sets dnsmasq Server's IP block range
 */
int aos_dnsmasq_set_ip_block(char* ip1, char* ip2, char* netmask)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq set ip_range  %s  %s  %s ", ip1, ip2, netmask);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * sets dnsmasq Server's IP block range
 */
int aos_dnsmasq_get_ip_block(char* ip1, char* ip2)
{
	char rslt[10240];
	int rsltlen = 10240;  
	aos_dnsmasq_retrieve_config(rslt, &rsltlen);

	strcpy(ip1, dnsmasq.ip1);
	strcpy(ip2, dnsmasq.ip2);
/*	strcat(result, " ");
	strcat(result, dnsmasq.netmask);*/
	//*resultlen = strlen(result);
//	printf ("%s\n", result);
	return 0;
}

/*
 * sets dnsmasq Server's lease time.
 */
int aos_dnsmasq_set_lease_time(char* lease_time)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq set lease_time  %s ", lease_time);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * gets dnsmasq Server's lease time.
 */
int aos_dnsmasq_get_lease_time(char* result, int* resultlen)
{
	char rslt[10240];
	int rsltlen = 10240;  
	aos_dnsmasq_retrieve_config(rslt, &rsltlen);

	strcpy(result, dnsmasq.leaseTime);
	*resultlen = strlen(result);
	printf ("%s\n", result);
	return 0;
}

/*
 * set except interface which the dnsmasq Server does not take effect
 */
int aos_dnsmasq_set_except_dev(char* dev)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq set except_dev  %s ", dev);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * adds an IP address and a MAC address binding
 */
int aos_dnsmasq_add_bind(char* label, char* mac, char* ip)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq add bind  %s  %s  %s ", label, mac, ip);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * removes a hosts table entry which associates IP addresses with hostnames 
 */
int aos_dnsmasq_del_host(char* label)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq del host  %s ", label);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 *  adds a hosts table entry which associates IP addresses with hostnames or domainnames
 */
int aos_dnsmasq_add_host(char* label, char* ip, char* domain)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq add host  %s  %s  %s ", label, ip, domain);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * remove an IP address and a MAC address binding
 */
int aos_dnsmasq_del_bind(char* label)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq del bind  %s ", label);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * gets bind address
 */
int aos_dnsmasq_get_bind(char* result, int* resultlen)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];
	int len;

	sprintf(cmd, "dnsmasq get bind ");

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	len = strlen(rslt);
	if (len > *resultlen)
	{
		strncpy(result, rslt, *resultlen);
		return eAosRc_LenTooShort;
	}
	else
	{
		strcpy(result, rslt);
		*resultlen = len;
	}
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

int aos_dnsmasq_server_get_binding_by_mac(char *mac, char *result)
{
	return 0;
}

int aos_dnsmasq_server_get_binding_by_ip(char *ip, char *result)
{
	return 0;
}

int aos_dnsmasq_server_get_binding_by_label(char *label, char *result)
{
	return 0;	
}
/*
 * sets dnsmasq Server's DNS IP address
 */
int aos_dnsmasq_set_dns(char* dns1, char* dns2)
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq set dns  %s  %s ", dns1, dns2);

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * gets dnsmasq Server's DNS IP address
 */
int aos_dnsmasq_get_dns(char* result, int* resultlen)
{
	char rslt[10240];
	int rsltlen = 10240;  
	aos_dnsmasq_retrieve_config(rslt, &rsltlen);

	strcpy(result, dnsmasq.dns1);
	strcat(result, " ");
	strcat(result, dnsmasq.dns2);
	*resultlen = strlen(result);
	printf ("%s\n", result);
	return 0;
}

/*
 * this is description
 */
int aos_dnsmasq_retrieve_config(char *result,int *resultlen)
{
	OmnString rslt = "";
	char* tmp;
	int len;
	char cmd[MAX_BUFF_LEN];
//	char alias[MAX_LEN];
//	char domainbind[MAX_LEN];
//	char ipbind[MAX_LEN];
//	char mac[MAX_MAC_STRING_LEN];
//	char ip[MAX_IP_STRING_LEN];
	//char label[MAX_LEN];
//	char domain[MAX_LEN];
	
	sprintf(cmd, "dnsmasq show config ");
	char temp[MAX_LEN];
    OmnString contents;
	OmnString hostlist;
	OmnString bindlist;
//	char *tmpsave;
//	char* p;

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	if (len > *resultlen)
	{
		strncpy(result, rslt, *resultlen);
		return eAosRc_LenTooShort;
	}
	else
	{
		strcpy(result, rslt);
		*resultlen = len;
	}
	
/*	int status;
	char *status_tag[] = {"", "", "", "", "", "", ""};
	char line[1024];

	p = rslt;

	while (*p) {
		if (sscanf(p, "%s\n", line) == 1) {
			for (int i = 0; i < (int)(sizeof(status_tag)); i++) {
				if (strcmp(line, status_tag[i]) == 0) {
					status = i + 1;
					p += strlen(line);
					continue;
				}
			}
			switch (status) {
				case 1:
					break;
				case 2:
					break;
				case 3:
					break;
				case 4:
					break;
				case 5:
					break;
				case 6:
					break;
				case 7:
					break;
			}
		}
	}
	*/
	memset(&dnsmasq, 0, sizeof(struct dnsmasqConfigEntry));	
	strcpy(temp,"");
    readBlock(result, "status : ", "\n\t hostname", temp, MAX_LEN);
	strcpy(dnsmasq.status, temp);
//	printf("    the status is : %s\n", dnsmasq.status);

    strcpy(temp,"");
	readBlock(result, "hostname : ", "ip1 :", temp, MAX_LEN);
	strcpy(dnsmasq.hostname, temp);
//	printf("the hostname is : %s\n", dnsmasq.hostname);

	strcpy(temp,"");
	readBlock(result, "ip1 : ", "\n\t      ip2 : ", temp, MAX_LEN);
	strcpy(dnsmasq.ip1, temp);
//	printf("    the ip1 is : %s\n", dnsmasq.ip1);
	
	strcpy(temp,"");
	readBlock(result, "ip2 : ", "\n\t  netmask : ", temp, MAX_LEN);
	strcpy(dnsmasq.ip2, temp);
//	printf("    the ip2 is : %s\n", dnsmasq.ip2);


    strcpy(temp,"");
   	readBlock(result, "netmask : ", "\n\tleaseTime : ", temp, MAX_LEN);
	strcpy(dnsmasq.netmask, temp);
//	printf("       the metmask is : %s\n", dnsmasq.netmask);
	
	strcpy(temp,"");
   	readBlock(result, "leaseTime : ", "\n\t     dns1 : ", temp, MAX_LEN);
	strcpy(dnsmasq.leaseTime, temp);
//	printf("       the leaseTime is : %s\n", dnsmasq.leaseTime);
	
	strcpy(temp,"");
   	readBlock(result, "dns1 : ", "\n\t     dns2 : ", temp, MAX_LEN);
	strcpy(dnsmasq.dns1, temp);
//	printf("       the dns1 is : %s\n", dnsmasq.dns1);
	
	strcpy(temp,"");
   	readBlock(result, "dns2 : ", "\n\texceptDev", temp, MAX_LEN);
	strcpy(dnsmasq.dns2, temp);
//	printf("       the dns2 is : %s\n", dnsmasq.dns2);
	
	strcpy(temp,"");
   	readBlock(result, "exceptDev : ", "\n\thost list ", temp, MAX_LEN);
	strcpy(dnsmasq.exceptDev , temp);
//	printf("       the exceptDev is : %s\n", dnsmasq.exceptDev );
/*	
    struct dnsmasqBindEntry * p;
    struct dnsmasqBindEntry * tmpp;
    
    struct dnsmasqHostsEntry * ptr;
    struct dnsmasqHostsEntry * tmpptr;
    
	aos_list_for_each_entry_safe(p, tmpp, &sgDnsmasqBindList, datalist)
    {       
       	aos_list_del(&p->datalist);
        free(p);
    }
	AOS_INIT_LIST_HEAD(&sgDnsmasqBindList);
	
	aos_list_for_each_entry_safe(ptr, tmpptr, &sgDnsmasqHostsList, datalist)
    {       
       	aos_list_del(&ptr->datalist);
        free(ptr);
    }
	AOS_INIT_LIST_HEAD(&sgDnsmasqHostsList);
    
	strcpy(temp,"");
   	readBlock(rslt, "\t\t\talias IP DOMAIN\n\t\t\t--------------\n\t\t\t", "\n", temp, MAX_LEN);
	if(strcmp(temp,"")!=0)
	{
		char *seperator=" ";
		strcpy(alias,"");
		strcpy(ip,"");
		strcpy(domain,"");
	    strcpy(alias,strtok_r(temp,seperator,&tmpsave));
		strcpy(ip,strtok_r(NULL,seperator,&tmpsave));
		strcpy(domain,strtok_r(NULL,seperator,&tmpsave));

	    printf("  the bind : %s\t%s\t%s\n", alias, ip, domain);

		struct dnsmasqBindEntry * ptr;

    	aos_list_for_each_entry(ptr, &sgDnsmasqBindList, datalist)
    	{       
    		if(strcmp(ptr->alias, alias)==0) 
   			{       
				return -1;
			}
      	}            

		struct dnsmasqHostsEntry * data;
		if((data = (struct dnsmasqHostsEntry *)malloc(sizeof(struct dnsmasqHostsEntry)))==NULL)
		{
			//printk("malloc error");
			return -1;
		}

		memset(data, 0, sizeof(struct dnsmasqHostsEntry));
		
		strcpy(data->alias, alias);	
		strcpy(data->ip, ip);
		strcpy(data->domain, domain);

		aos_list_add_tail((struct aos_list_head *)&data->datalist, &sgDnsmasqHostsList);
		
	}

	while(1)
	{
		memset(temp, 0, sizeof(256));
		strcpy(domainbind, domain);
		strcat(domainbind, "\n\t\t\t");
   		readBlock(rslt, domainbind, "\n", temp, MAX_LEN);
	 //	printf("  the tmp is %s\n", tmp);
		if(strcmp(temp,"") == 0)
			break;

		strcpy(alias,"");
		strcpy(ip,"");
		strcpy(domain,"");
	    strcpy(alias, strtok_r(temp," ",&tmpsave));
		strcpy(ip, strtok_r(NULL," ",&tmpsave));
		strcpy(domain, strtok_r(NULL," ",&tmpsave));
	    printf("  the host list : %s\t%s\t%s\n", alias, ip, domain);

		struct dnsmasqHostsEntry * ptr;

    	aos_list_for_each_entry(ptr, &sgDnsmasqHostsList, datalist)
    	{       
    		if(strcmp(ptr->alias, alias)==0) 
   			{       
				return -1;
			}
      	}            

		struct dnsmasqHostsEntry * data;
		if((data = (struct dnsmasqHostsEntry *)malloc(sizeof(struct dnsmasqHostsEntry)))==NULL)
		{
			//printk("malloc error");
			return -1;
		}
		memset(data, 0, sizeof(struct dnsmasqHostsEntry));
		strcpy(data->alias, alias);
		strcpy(data->ip, ip);
		strncpy(data->domain, domain,MAX_IP_STRING_LEN);
		aos_list_add_tail((struct aos_list_head *)&data->datalist, &sgDnsmasqHostsList);                                                  
	}
	//mac bind list
	strcpy(temp,"");
   	readBlock(rslt, "\t\t\talias MAC IP\n\t\t\t--------------\n\t\t\t", "\n", temp, MAX_LEN);
	if(strcmp(temp,"")!=0)
	{
		//char c;
		char *seperator=" ";
		strcpy(alias,"");
		strcpy(mac,"");
		strcpy(ip,"");
	    strcpy(alias,strtok_r(temp,seperator,&tmpsave));
		strcpy(mac,strtok_r(NULL,seperator,&tmpsave));
		strcpy(ip,strtok_r(NULL,seperator,&tmpsave));

	    printf("  the bind : %s\t%s\t%s\n", alias, mac, ip);

		struct dnsmasqBindEntry * ptr;

    	aos_list_for_each_entry(ptr, &sgDnsmasqBindList, datalist)
    	{       
    		if(strcmp(p->alias, alias)==0) 
   			{       
				return -1;
			}
      	}            


		struct dnsmasqBindEntry * bindptr;
		if(( bindptr = (struct dnsmasqBindEntry *)malloc(sizeof(struct dnsmasqBindEntry)))==NULL)
		{
			//printk("malloc error");
			return -1;
		}
		memset(bindptr, 0, sizeof(struct dnsmasqBindEntry));
		strcpy(bindptr->alias, alias);
		strcpy(bindptr->mac, mac);
		strcpy(bindptr->ip, ip);
		aos_list_add_tail((struct aos_list_head *)&bindptr->datalist, &sgDnsmasqBindList);

	}

	while(1)
	{
		memset(temp, 0, sizeof(256));
		strcpy(ipbind, ip);
		strcat(ipbind, "\n\t\t\t");
   		readBlock(rslt, ipbind, "\n", temp, MAX_LEN);
	 //	printf("  the tmp is %s\n", tmp);
		if(strcmp(temp,"") == 0)
			break;

		strcpy(alias,"");
		strcpy(mac,"");
		strcpy(ip,"");
	    strcpy(alias, strtok_r(temp," ",&tmpsave));
		strcpy(mac, strtok_r(NULL," ",&tmpsave));
		strcpy(ip, strtok_r(NULL," ",&tmpsave));
	    printf("  the bind : %s\t%s\t%s\n", alias, mac, ip);

		struct dnsmasqBindEntry * ptr;

    	aos_list_for_each_entry(ptr, &sgDnsmasqBindList, datalist)
    	{       
    		if(strcmp(ptr->alias, alias)==0) 
   			{       
				return -1;
			}
      	}            

		struct dnsmasqBindEntry * data;                                                    
		if((data = (struct dnsmasqBindEntry *)malloc(sizeof(struct dnsmasqBindEntry)))==NULL)                                               
		{                                                    
			//printk("malloc error");                                                    
			return -1;                                                    
		}                                                    
		memset(data, 0, sizeof(struct dnsmasqBindEntry));                                                    
		strcpy(data->alias, alias);                                                    
		strcpy(data->mac, mac);                                                    
		strcpy(data->ip, ip);                                                    
		aos_list_add_tail((struct aos_list_head *)&data->datalist, &sgDnsmasqBindList);                                                    
	}
*/	
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * clear current config
 */
int aos_dnsmasq_clear_config()
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq clear config ");

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * save current config
 */
int aos_dnsmasq_save_config()
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq save config ");

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

/*
 * reload dnsmasq Server configuration
 */
int aos_dnsmasq_load_config()
{
	OmnString rslt = "";
	char* tmp;
	char cmd[MAX_BUFF_LEN];

	sprintf(cmd, "dnsmasq load config ");

	OmnCliProc::getSelf()->runCliAsClient(cmd, rslt);
	tmp = rslt.getBuffer();
	tmp += rslt.find(0, false) + 1;

	return *((int*)tmp);
}

int readBlock(const char *buffer, const char *start, const char *end, char *result, int result_len)
{
        int buffer_len,start_len,end_len;
        char *p_start, *p_end;

        if(!buffer || !start || !end || result_len<2)
                return -1;

        start_len = strlen(start);
        end_len = strlen(end);
        buffer_len = strlen(buffer);

        result[0]=0;

        if( buffer_len <= start_len+end_len )
                return -1;

        p_start = strstr( buffer, start );
        if ( !p_start )
                return -1;

        p_end = strstr( p_start+start_len, end );
        if ( !p_end )
                return -1;

	strncpy(result, p_start+start_len, MIN(result_len-1,p_end-p_start-start_len));
	result[MIN(result_len-1,p_end-p_start-start_len)]=0;
        return 0;
 }
