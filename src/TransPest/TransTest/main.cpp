////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005
// Packet Engineering, Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification is not permitted unless authorized in writing by a duly
// appointed officer of Packet Engineering, Inc. or its derivatives
//
// Description:
// This file is automatically generated by the TorturerGen facility.  
//
// Modification History:
// 3/19/2007: Created by TorturerGen facility
////////////////////////////////////////////////////////////////////////////

#include "Actions/ActAddAttr.h"
#include "AppMgr/App.h"
#include "DataStore/StoreMgr.h"
#include "Debug/Debug.h"
#include "IdGen/IdGenMgr.h"
#include "Porting/Sleep.h"
#include "Proggie/ReqDistr/ReqDistr.h"
#include "Query/QueryMgr.h"
#include "SEUtil/SeXmlParser.h"
#include "SEUtil/XmlTag.h"
#include "SEUtil/XmlDoc.h"
#include "SEUtilServer/SeIdGenMgr.h"
#include "SEModules/LogMgr.h"
#include "SEUtilServer/SeIdGenMgr.h"
#include "SEModules/LoginMgr.h"
#include "Security/Session.h"
#include "Security/SecurityMgr.h"
#include "Security/SessionMgr.h"
#include "SiteMgr/SiteMgr.h"
#include "Util/OmnNew.h"
#include "Util/File.h"
#include "util2/global_data.h"
#include "VpdParser/VpdParser.h"
#include "WordMgr/WordMgr1.h"
#include "IILMgr/IIL.h"
#include "IILMgr/IILDocid.h"
#include "SearchEngine/DocMgr.h"
#include "SearchEngine/DocServer.h"
#include "IILMgr/IILMgr.h"
#include "SEServer/Ptrs.h"
#include "SEModules/ImgProc.h"
#include "SEServer/SeReqProc.h"
#include "Tester/TestSuite.h"
#include "Tester/TestMgr.h"
#include "Tester/TestPkg.h"
#include "Util1/MemMgr.h"
#include "WordParser/Ptrs.h"
#include "WordParser/WordParser.h"

#include "IILAgent/Testers/IILAgentTester.h"
#include "IILAgent/Testers/TestSuite.h"
#include "IILAgent/IILAgent.h"
#include "IILServer/Ptrs.h"
#include "IILServer/IILReqProc.h"
#include "IILServer/AllIILTrans.h"
#include "TransServer/TransMgr.h"

#include <sys/types.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string>

using namespace std;

int gAosLogLevel = 1;
char *firstAddr;

int  clientMain(int, char**);
int	 serverMain(int, char**);

bool
testStart(int child_client_pid, int child_server_pid, int argc, char **argv)
{
	bool killedClient = false; 
	bool killedServer = false;

	while(1)
	{
		int time = rand()% 200;		
		cout << "..............................................................."
			 <<	"parent sleep:" << time
			 << ",to kill Serve or client"
			 << "........................................................."
			 << endl;
		OmnSleep(time);

		if ((rand() & 0x0001)== 1 && !killedClient)
		{
			cout << ">>>>>>>>>>>>>>------------>>>>>>>>>>>>>>>>>>>>>>>>>---------------------killclient:\t"
				<< child_client_pid << "(" << getpid() << ")" 
				<< "----------------------------<<<<<<<<<<<<<<<<<<<<--------------------------<<<<<<<<<<<<"
				<< endl;
			kill(child_client_pid, 9);
			waitpid(child_client_pid);
			killedClient = true;

			//The possibility of 10 percent to  kill server
			if((rand()%100) < 10 && !killedServer)
			{
				cout << ">>>>>>>>>>>>>>------------>>>>>>>>>>>>>>>>>>>>>>>>>---------------killserver(after kill client):\t"
					<< child_server_pid << "(" << getpid() << ")" 
					<< "----------------------------<<<<<<<<<<<<<<<<<<<<--------------------------<<<<<<<<<<<<"
					<< endl;
				kill(child_server_pid, 9);
				waitpid(child_server_pid);
				killedServer = true;
			}
		}
		else if(!killedServer)	
		{
			cout << ">>>>>>>>>>>>>>------------>>>>>>>>>>>>>>>>>>>>>>>>>---------------------killserver:\t"
				<< child_server_pid << "(" << getpid() << ")" 
				<< "----------------------------<<<<<<<<<<<<<<<<<<<<--------------------------<<<<<<<<<<<<"
				<< endl;
			kill(child_server_pid, 9);
			waitpid(child_server_pid);
			killedServer = true;
			
			//The possibility of 10 percent to  kill client
			if((rand()%100) < 10 && !killedClient)
			{
				cout << ">>>>>>>>>>>>>>------------>>>>>>>>>>>>>>>>>>>>>>>>>----------------killclient(after kill server):\t"
					<< child_client_pid << "(" << getpid() << ")" 
					<< "----------------------------<<<<<<<<<<<<<<<<<<<<--------------------------<<<<<<<<<<<<"
					<< endl;
				kill(child_client_pid, 9);
				waitpid(child_client_pid);
				killedClient = true;
			}
		}
			
		if(killedClient)
		{
			if ((child_client_pid=fork())== 0)	
			{
				OmnSleep(rand()% 30);
				cout << "-----********-------***********----------****************----------------start client:\t"
					<< getpid() 
					<< "--------------------*************---------------------***************************" << endl;
				clientMain(argc, argv);
			}
			killedClient = false;
		}

		if(killedServer)
		{
			if ((child_server_pid=fork())== 0)
			{
				OmnSleep(rand()% 30);
				cout << "-----********-------***********----------****************----------------start server:\t"
					<< getpid() 
					<< "--------------------*************---------------------***************************" << endl;
				serverMain(argc, argv);
			}
			killedServer = false;
		}	
	}
}


int 
main(int argc, char **argv)
{
	int child_client_pid;
	int child_server_pid;
	int status;

	const char *cmd = "rm /usr/Data/trans/* /usr/Data/transServer/*";
	system(cmd);
	cout << "--------------------------------Parent ID:\t" << getpid() << "-------------" << endl;
	
	//share memory
	int shmid;
	struct shmid_ds dsbuf;
	int size = getpagesize()*2000 ;
	if ((shmid=shmget(IPC_PRIVATE,size, 0))<0)
	{
	    perror("share memery allocate error!");
	    exit(1);
	}
	
	shmctl(shmid, IPC_STAT, &dsbuf);

	firstAddr = (char*)shmat(shmid, NULL, 0);
	if ((int)firstAddr==-1)
	{
		perror("share memery load error!");
		exit(1);
	}

	if ((child_client_pid=fork())== 0)	
	{
		firstAddr = (char*)shmat(shmid, NULL, 0);
		cout << "---------------------------init start client: \t" << getpid() << "-----------------------" <<  endl;
		clientMain(argc, argv);
	}
	else
	{
		if ((child_server_pid=fork())== 0)
		{
			cout << "---------------------------init start server:\t" << getpid() << "-------------------------" << endl;
			serverMain(argc, argv);
		}
		else
		{
			testStart(child_client_pid, child_server_pid, argc, argv);
		}
	}
	
	wait(&status);
	shmdt((void *)firstAddr);
	shmctl(shmid, IPC_RMID, 0);
	return 0;
} 

 
int 
clientMain(int argc, char **argv)
{

	aos_global_data_init();
	OmnApp theApp(argc, argv);

	OmnApp::setConfig("config_client.txt");
	AosXmlDoc::staticInit(OmnApp::getAppConfig());
	try
	{
		theApp.startSingleton(OmnNew AosIILAgentSingleton());
		AosIILAgentSelf->start(OmnApp::getAppConfig());
	}
	catch (const OmnExcept &e)
	{
		OmnAlarm << "Failed to start the application: " << e.toString() << enderr;
		theApp.exitApp();
		return 0;
	}

	int tries = 10000;
	OmnTestMgrPtr testMgr = OmnNew OmnTestMgr("Transaction", "Try", "Chen Ding");
	testMgr->setTries(tries);
	testMgr->addSuite(AosIILAgentTestSuite::getSuite());
	
	cout << "Start Testing ..." << endl;
	testMgr->start();
	cout << "\nFinished. " << testMgr->getStat() << endl;
	testMgr = 0;

	while(1)
	{
		OmnSleep(10000);
	}
	return 0;
} 

int 
serverMain(int argc, char **argv)
{
	aos_global_data_init();
	OmnApp theApp(argc, argv);

	OmnApp::setConfig("config_server.txt");
	try
	{
		theApp.startSingleton(OmnNew AosTransMgrSingleton());
		AosTransMgrSelf->start(OmnApp::getAppConfig());
	}
	catch (const OmnExcept &e)
	{
		OmnAlarm << "Failed to start the application: " << e.toString() << enderr;
		theApp.exitApp();
		return 0;
	}

	AosIILReqProc::config(OmnApp::getAppConfig());
	AosIILReqProcPtr proc = OmnNew AosIILReqProc();
	AosReqDistr reqDistr(proc);
	if (!reqDistr.config(OmnApp::getAppConfig()->toString()))
	{
		OmnAlarm << "Failed the configuration: " 
			<< OmnApp::getAppConfig()->toString() << enderr;
		theApp.exitApp();
		return -1;
	}
	reqDistr.start();
	while(1)
	{
		OmnSleep(10000);
	}

	return 0;
} 


